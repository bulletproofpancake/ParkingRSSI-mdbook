<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>KNN Classifier - ParkingRSSI Documentation</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../chapters/applicationOverview.html">Application Overview</a></li><li class="chapter-item expanded affix "><a href="../../chapters/algorithmOverview.html">Algorithm Overview</a></li><li class="chapter-item expanded affix "><a href="../../chapters/projectStructure.html">Project Structure</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../../chapters/scripts/knn-classifier.html" class="active"><strong aria-hidden="true">1.</strong> KNN Classifier</a></li><li class="chapter-item expanded "><a href="../../chapters/models/models.html"><strong aria-hidden="true">2.</strong> Models</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/models/rowdata.html"><strong aria-hidden="true">2.1.</strong> RowData</a></li><li class="chapter-item expanded "><a href="../../chapters/models/session.html"><strong aria-hidden="true">2.2.</strong> Session</a></li><li class="chapter-item expanded "><a href="../../chapters/scripts/router.html"><strong aria-hidden="true">2.3.</strong> Router</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/models/singletons.html"><strong aria-hidden="true">3.</strong> Singletons</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/models/prefs.html"><strong aria-hidden="true">3.1.</strong> Prefs</a></li><li class="chapter-item expanded "><a href="../../chapters/models/dbhelper.html"><strong aria-hidden="true">3.2.</strong> DBHelper</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/views/views.html"><strong aria-hidden="true">4.</strong> Views</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/scripts/main-activity.html"><strong aria-hidden="true">4.1.</strong> Main Activity</a></li><li class="chapter-item expanded "><a href="../../chapters/views/sessionFragment.html"><strong aria-hidden="true">4.2.</strong> Session Fragment</a></li><li class="chapter-item expanded "><a href="../../chapters/views/scanRouterFragment.html"><strong aria-hidden="true">4.3.</strong> Scan Router Fragment</a></li><li class="chapter-item expanded "><a href="../../chapters/views/dataFragment.html"><strong aria-hidden="true">4.4.</strong> Data Fragment</a></li><li class="chapter-item expanded "><a href="../../chapters/views/homeFragment.html"><strong aria-hidden="true">4.5.</strong> Home Fragment</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ParkingRSSI Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="knn-classifier"><a class="header" href="#knn-classifier">KNN Classifier</a></h1>
<p>The <code>KNN Classifier</code> class contains the logic implementing the <a href="https://bit.ly/2OcMqHv">K-Nearest Neighbor Algorithm</a>.
It is located at <code>app &gt; java &gt; com.silentrald.parkingrssi &gt; KNNClassifier.kt</code>.
This page is for explaining the source code of how the algorithm is implemented.
For a more high level overview, please refer to the <a href="algorithmOverview.html">Algorithm Overview</a>.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>The <code>KNN Classifier</code> class has multiple fields which are needed in order to calculate the number of available parking spaces
using the algorithm.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>k</td><td><code>var k: Int = 3</code></td><td>The number of neighbors to be evaluated by the algorithm. The value is set to 3 by default.</td></tr>
<tr><td>inputSize</td><td><code>var inputSize: Int = 6</code></td><td>The number of routers to get RSSI values from.</td></tr>
<tr><td>matrix</td><td><code>val matrix = arrayListOf&lt;ArrayList&lt;Float&gt;&gt;()</code></td><td>A collection of RSSI values gathered from the routers.</td></tr>
<tr><td>labels</td><td><code>val labels = arrayListOf&lt;Int&gt;()</code></td><td>A collection of the amount of cars for a set of RSSI values.</td></tr>
</tbody></table>
</div>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="addpoint"><a class="header" href="#addpoint">addPoint</a></h3>
<p>The <code>addPoint</code> method adds a point to the dataset. This point contains the RSSI values and the amount of cars for that set.</p>
<h4 id="snippet"><a class="header" href="#snippet">Snippet</a></h4>
<pre><code class="language-kt">fun addPoint(point: ArrayList&lt;Float&gt;, label: Int) {
    if (point.size != inputSize) {
      return
    }

    matrix.add(point)
    labels.add(label)

    k = sqrt(matrix.size.toDouble()).toInt()
  }
</code></pre>
<h4 id="parameters"><a class="header" href="#parameters">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>point</td><td><code>point: ArrayList&lt;Float&gt;</code></td><td>The RSSI values received from the routers.</td></tr>
<tr><td>label</td><td><code>label: Int</code></td><td>The amount of cars in the parking lot when the point is recorded.</td></tr>
</tbody></table>
</div>
<h4 id="implementation"><a class="header" href="#implementation">Implementation</a></h4>
<p>At the start of the method, the size of the point is compared to the <code>inputSize</code>.
Each router sends a single RSSI value which is contained as a list in the <code>point</code> variable.
This check then is to ensure that all routers have sent an RSSI value before it is added to the database.</p>
<pre><code class="language-kt">// For example:
// point = {-27.0,-36.0,-20.0,-27.0,-31.0}

// Given that there are 5 entries in point:
// point.size = 5

// inputSize is based on the amount of routers selected.
// Given that each router sends a single RSSI value:
// inputSize = 5

// Because the point.size and inputSize is the same
// the method would not return and continue to the next step

if (point.size != inputSize){
    return
}
</code></pre>
<p>If the <code>point</code> entered is valid, it gets added to the <code>matrix</code> and the <code>label</code> gets added to the <code>labels</code>.
In essence, this &quot;pairs&quot; the <code>label</code> with the <code>point</code> entered as they share the same index as they get added to their lists at the same time.</p>
<pre><code class="language-kt">// For example:
// point = {-27.0,-36.0,-20.0,-27.0,-31.0}
// label = 0
// matrix = {}
// labels = {}

// The reason matrix is empty is because there are no points added to it yet.
// labels is empty for the same reason.

matrix.add(point)

// matrix = [{-27.0,-36.0,-20.0,-27.0,-31.0}]

// After adding the point, the matrix now contains the list of RSSI values from the point.
// This is why in the declaration of the matrix, it is an arrayListof&lt;ArrayList&lt;Float&gt;&gt;()
// The matrix is a list for a list of float variables.

labels.add(label)

// labels = {0}

// After adding the label, the labels list now contain the value of the label.
</code></pre>
<p>Once the <code>point</code> and <code>label</code> has been added to the database, the value of <code>k</code> is adjusted.</p>
<pre><code class="language-kt">// For example, another point has been added to the matrix:
// matrix = [{-27.0,-36.0,-20.0,-27.0,-31.0}, -26.0,-37.0,-20.0,-28.0,-30.0}]
// matrix.size = 2
// matrix.size.toDouble = 2.0
// sqrt(matrix.size.toDouble()) = 1.41421356237309511.0
// sqrt(matrix.size.toDouble()).toInt() = 1

k = sqrt(matrix.size.toDouble()).toInt()

// By doing this, the points gets compared to more neighbors as it increases.
</code></pre>
<p>As mentioned before, this &quot;pairs&quot; the <code>point</code> and <code>label</code> together.
For example, the data collected from five routers can be presented in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>label</th><th>66852627208993-xiaomi-repeater-v3_miapdb21</th><th>66852627204643-xiaomi-repeater-v3_miapca23</th><th>66852627209260-xiaomi-repeater-v3_miapdc2c</th><th>66852627198541-xiaomi-repeater-v3_miapb24d</th><th>66852627208795-xiaomi-repeater-v3_miapda5b</th></tr></thead><tbody>
<tr><td>0</td><td>-27.0</td><td>-36.0</td><td>-20.0</td><td>-27.0</td><td>-31.0</td></tr>
<tr><td>1</td><td>-26.0</td><td>-37.0</td><td>-20.0</td><td>-28.0</td><td>-30.0</td></tr>
<tr><td>2</td><td>-25.0</td><td>-43.0</td><td>-18.0</td><td>-29.0</td><td>-31.0</td></tr>
<tr><td>3</td><td>-26.0</td><td>-39.0</td><td>-21.0</td><td>-27.0</td><td>-32.0</td></tr>
<tr><td>4</td><td>-26.0</td><td>-39.0</td><td>-24.0</td><td>-25.0</td><td>-31.0</td></tr>
<tr><td>5</td><td>-25.0</td><td>-41.0</td><td>-25.0</td><td>-23.0</td><td>-31.0</td></tr>
</tbody></table>
</div>
<p>However, in the code these data are stored in two different lists, the <code>matrix</code> and <code>labels</code>, and they can be represented like so:</p>
<pre><code class="language-json">[
  {
    &quot;labels&quot;: &quot;{0,1,2,3,4,5}&quot;,
    &quot;matrix&quot;: &quot;{-27.0,-36.0,-20.0,-27.0,-31.0},{-26.0,-37.0,-20.0,-28.0,-30.0},{-25.0,-43.0,-18.0,-29.0,-31.0},{-26.0,-39.0,-21.0,-27.0,-32.0},{-26.0,-39.0,-24.0,-25.0,-31.0},{-25.0,-41.0,-25.0,-23.0,-31.0}&quot;
  }
]
</code></pre>
<p>Or in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>labels</th><th>matrix</th></tr></thead><tbody>
<tr><td>0</td><td>{-27.0,-36.0,-20.0,-27.0,-31.0}</td></tr>
<tr><td>1</td><td>{-26.0,-37.0,-20.0,-28.0,-30.0}</td></tr>
<tr><td>2</td><td>{-25.0,-43.0,-18.0,-29.0,-31.0}</td></tr>
<tr><td>3</td><td>{-26.0,-39.0,-21.0,-27.0,-32.0}</td></tr>
<tr><td>4</td><td>{-26.0,-39.0,-24.0,-25.0,-31.0}</td></tr>
<tr><td>5</td><td>{-25.0,-41.0,-25.0,-23.0,-31.0}</td></tr>
</tbody></table>
</div>
<h3 id="calculatedistance"><a class="header" href="#calculatedistance">calculateDistance</a></h3>
<p>The <code>calculateDistance</code> method aggregates the distance between two collections of RSSI values.
In the app, one collection is from the current RSSI values received by the device
and another is from the existing RSSI values added to the <code>matrix</code>.
This is because the <code>calculateDistance</code> method is used when the app is <a href="#predict">predicting</a>.</p>
<p>It helps to think of each collection of RSSI values as a coordinate, however as the number of routers increase
so too does the dimensions in which these coordinates exist, which is why the Euclidean Distance formula is used to
calculate the distance between each point.</p>
<blockquote>
<p><strong>NOTE:</strong>
For a further in-depth breakdown of the usage of the Euclidean Distance formula,
please refer to the <a href="algorithmOverview.html#getting-the-nearest-points">Getting the nearest points</a>
section in the Algorithm Overview.</p>
</blockquote>
<h4 id="snippet-1"><a class="header" href="#snippet-1">Snippet</a></h4>
<pre><code class="language-kt">private fun calculateDistance(ps1: ArrayList&lt;Float&gt;, ps2: ArrayList&lt;Float&gt;): Float {
    if (ps1.size != ps2.size) return -1f

    var distance = 0f
    for (i in 0 until ps1.size) {
      distance += (ps1[i] - ps2[i]).pow(2) // (x1 - x2) ^ 2
    }
    return distance
  }
</code></pre>
<h4 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>ps1</td><td><code>ps1: ArrayList&lt;Float&gt;</code></td><td>The current RSSI values being detected by the device.</td></tr>
<tr><td>ps2</td><td><code>ps2: ArrayList&lt;Float&gt;</code></td><td>The RSSI values from the <code>matrix</code>.</td></tr>
</tbody></table>
</div>
<h4 id="returns"><a class="header" href="#returns">Returns</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Returns</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>distance</td><td><code>Float</code></td><td>The aggregated distance between the two collections of RSSI values.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h4>
<pre><code class="language-kt">// Compare the sizes of the parameters to check if it is valid.
// Returning a negative distance would mean that the parameters are invalid.
if(ps1.size != ps2.size) return -1f

// The next line creates a variable distance.
// This is where the aggregated distances will be stored and returned.
var distance = 0f

// The next line states that until the index reaches the size of ps1,
// the Euclidean Distance of the two points would be added to distance.
for (i in 0 until ps1.size){
    distance += (ps1[i] - ps2[i]).pow(2)
}

// Once the loop is finished, the distance would be returned.
return distance
</code></pre>
<p>Let us say for example that we are working with the following data:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>ps1</th><th>ps2</th></tr></thead><tbody>
<tr><td>0</td><td>-27.0</td><td>-26.0</td></tr>
<tr><td>1</td><td>-36.0</td><td>-37.0</td></tr>
<tr><td>2</td><td>-20.0</td><td>-20.0</td></tr>
<tr><td>3</td><td>-27.0</td><td>-28.0</td></tr>
<tr><td>4</td><td>-31.0</td><td>-30.0</td></tr>
</tbody></table>
</div>
<p>When we use the function, we first check if the size of both lists are the same.</p>
<pre><code class="language-kt">if(ps1.size != ps2.size) return -1f
</code></pre>
<p>This means that if we use the data given above, we would not return <code>-1f</code> because both lists have 5 items in them,
however if ps1 or ps2 does not have the same number of items, we would return <code>-1f</code> and we would not calculate the distances between those points
because the given list of points are invalid.
The reason we are returning <code>-1f</code> is because the function requires a number to be returned which is the <code>distance</code>, therefore, if we return a negative distance,
this means that there has been an error in processing the given points.</p>
<p>Afterwards, the distance is computed by going through each item in the lists and aggregating their distances.</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>ps1</th><th>ps2</th><th>distance</th><th>\[\sum_{i=0}^{ps1.size} {distance}\]</th></tr></thead><tbody>
<tr><td>0</td><td>-27.0</td><td>-26.0</td><td>1</td><td>1</td></tr>
<tr><td>2</td><td>-36.0</td><td>-37.0</td><td>1</td><td>2</td></tr>
<tr><td>2</td><td>-20.0</td><td>-20.0</td><td>0</td><td>2</td></tr>
<tr><td>3</td><td>-27.0</td><td>-28.0</td><td>1</td><td>3</td></tr>
<tr><td>4</td><td>-31.0</td><td>-30.0</td><td>1</td><td>4</td></tr>
</tbody></table>
</div>
<p>After this loop has been finished, we have arrived at the distance of <code>4</code>,
which means the calculated distance that will be returned form the function will be <code>4</code>.</p>
<h3 id="predict"><a class="header" href="#predict">predict</a></h3>
<p>The <code>predict</code> method is where the actual implementation of the K-Nearest Neighbor algorithm as it predicts
the amount of cars taken with the <code>point</code> given to it.</p>
<h4 id="snippet-2"><a class="header" href="#snippet-2">Snippet</a></h4>
<pre><code class="language-kt">fun predict(point: ArrayList&lt;Float&gt;): Int {
    val distances = arrayListOf&lt;Pair&lt;Float, Int&gt;&gt;()
    for (i in 0 until matrix.size) {
      distances.add(Pair(calculateDistance(point, matrix[i]), labels[i]))
    }

    distances.sortWith(compareBy { it.first })
    Log.i(&quot;KNN&quot;, distances.toString())

    val hashmap = hashMapOf&lt;Int, Int&gt;()

    var end = k.coerceAtMost(matrix.size)
    for (i in 0 until end) {
      val classification = distances[i].second
      hashmap[classification] = hashmap.getOrDefault(classification, 0) + 1
    }

    // Get Max (Plurality)
    var max = -1
    val outputs = arrayListOf&lt;Int&gt;()
    for ((key, value) in hashmap) {
      if (value &gt; max) {
        max = value
        outputs.clear()
        outputs.add(key)
      } else if (value == max) {
        outputs.add(key)
      }
    }

    if (outputs.size == 1) {
      return outputs[0]
    }

    // Tie-breaking
    while (end &gt; 0) {
      end--
      val classification = distances[end].second
      hashmap[classification]?.dec()

      max = -1
      outputs.clear()
      for ((key, value) in hashmap) {
        if (value &gt; max) {
          max = value
          outputs.clear()
          outputs.add(key)
        } else if (value == max) {
          outputs.add(key)
        }
      }

      if (outputs.size == 1) {
        return outputs[0]
      }
    }

    // Just return the first one
    return distances[0].second
  }
</code></pre>
<h4 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>point</td><td><code>ArrayList&lt;Float&gt;</code></td><td>The current RSSI values being detected by the device.</td></tr>
</tbody></table>
</div>
<h4 id="returns-1"><a class="header" href="#returns-1">Returns</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Returns</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>outputs[0]</td><td><code>Int</code></td><td>The largest <code>label</code> recorded in the database.</td></tr>
<tr><td>distances[0].second</td><td><code>Int</code></td><td>The <code>label</code> of the nearest neighbor to the <code>point</code>.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h4>
<p>At the start of the <code>predict</code> method, a List of a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/"><code>Pair</code></a>
of types <code>Float</code> and <code>Int</code> are created and stored in the variable <code>distances</code>.
The <code>Float</code> is responsible for containing the distance from the <code>point</code> to the existing points added in the database,
while the <code>Int</code> contains the amount of cars expected for the point according to the database.</p>
<pre><code class="language-kt">val distances = arrayListOf&lt;Pair&lt;Float, Int&gt;&gt;()

for (i in 0 until matrix.size){
  distances.add(Pair(calculateDistance(point,matrix[i]), labels[i]))
}
</code></pre>
<p>For example, the given data is the following:</p>
<pre><code>label = {2,3,4}
matrix = [
  {-25.0,-43.0,-18.0,-29.0,-31.0},
  {-26.0,-39.0,-21.0,-27.0,-32.0},
  {-26.0,-39.0,-24.0,-25.0,-31.0}
  ]
point = {-26.0,-35.0,-21.0,-26.0,-27.0}
</code></pre>
<p>When graphed into a table, it would look like the following:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>labels[i]</th><th>matrix[i]</th><th>point</th></tr></thead><tbody>
<tr><td>0</td><td>2</td><td>-25.0,-43.0,-18.0,-29.0,-31.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
<tr><td>1</td><td>3</td><td>-26.0,-39.0,-21.0,-27.0,-32.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
<tr><td>2</td><td>4</td><td>-26.0,-39.0,-24.0,-25.0,-31.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
</tbody></table>
</div>
<p>When the distances are calculated and paired, we get the following result:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>Pair(calculateDistance,labels[i])</th></tr></thead><tbody>
<tr><td>0</td><td>(98.0, 2)</td></tr>
<tr><td>1</td><td>(41.0, 3)</td></tr>
<tr><td>2</td><td>(41.0, 4)</td></tr>
</tbody></table>
</div>
<p>After calculating the <code>distances</code>, it is sorted according to the calculated distance which is the <code>first</code> item in the pair.</p>
<pre><code class="language-kt">distances.sortWith(compareBy {it.first})
</code></pre>
<p>Once sorted, the <code>distances</code> is now the following:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>Pair(calculateDistance,labels[i])</th></tr></thead><tbody>
<tr><td>0</td><td>(41.0, 3)</td></tr>
<tr><td>1</td><td>(41.0, 4)</td></tr>
<tr><td>2</td><td>(98.0, 2)</td></tr>
</tbody></table>
</div>
<p>After sorting the <code>distances</code>, a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-map/"><code>hashmap</code></a>
is created in order to store the amount of neighbors for each classification (the number of cars or label).</p>
<p>For example:</p>
<blockquote>
<p><strong>NOTE:</strong> Additional data has been added in order to provide a more clear example.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>distances</th><th>label</th></tr></thead><tbody>
<tr><td>0</td><td>35.0</td><td>3</td></tr>
<tr><td>1</td><td>41.0</td><td>3</td></tr>
<tr><td>2</td><td>41.0</td><td>4</td></tr>
<tr><td>3</td><td>98.0</td><td>2</td></tr>
</tbody></table>
</div>
<p>When the data is stored into the hashmap, it can be seen like so:</p>
<pre><code class="language-kt">val hashmap = hashMapOf&lt;Int, Int&gt;()
// hashmap = {}

var end = k.coerceAtMost(matrix.size)
// matrix.size = 4
// since k = sqrt(matrix.size.toDouble()).toInt()
// k = 2 for this example
// therefore, end = 2

for (i in 0 until end){
  val classification = distances[i].second
  // In the pair, distance[0] = (35.0, 3)
  // By getting the second value in the pair
  // classification = 3

  hashmap[classification] = hashmap.getOrDefault(classification, 0)+1
  // hashmaps are similar to pairs, but they function differently.
  // hashmaps are key, value pairs
  // wherein the first element is the key and the second element is the value.
  // keys can be used as an index and they can store a value isolated from the items in the hashmap

  // in the line above, hashmap[classification] sets a value that gets paired to the classification
  // which in the case of the current i (0) is 3
  // So when it is visualized
  // hashmap = {3=null}
  // when hashmap.getOrDefault(classification, 0)+1 gets called
  // the value paired(null) to the classification(3) either gets set to
  // a number or set to the default value of 0 then incremented by 1
  // since the current value is null, it is set to 0 then incremented by 1
  // so after the first iteration hashmap = {3=1}

  // since this is in a loop until the end(2) is reached
  // the next iteration has the current values:
  // distance[1] = (41.0, 3)
  // classification = 3
  
  // now when hashmap.getOrDefault is ran,
  // hashmap[3] is already equal to 1 due to the previous iteration
  // so in this iteration, the value of hashmap[3] is incremented
  // hashmap = {3=2}
}
</code></pre>
<p>Due to the limitation set on the <code>k</code> value, the algorithm only had a single classification,
but if we are to go through all of the labels in <code>distances</code>, the hashmap would have the following value</p>
<pre><code class="language-kt">hashmap = {2=1, 3=2, 4=1}
</code></pre>
<p>These means that for the current point,
it has one neighbor classified as 2,
two neighbors classified as 3,
and one neighbor classified as 4.</p>
<p>After classifying the neighbors, the most number of neighbors of the same classification must be returned,
which is retrieved by the following lines of code:</p>
<pre><code class="language-kt">// set to -1 as the values of the hashmap
// would always be greater than this
var max = -1
// created to contain the classification
// of the greatest amount of neighbors
val outputs = arrayListOf&lt;Int&gt;()
for ((key, value) in hashmap) {
  if (value &gt; max) {
    max = value
    outputs.clear()
    outputs.add(key)
  } else if (value == max) {
    outputs.add(key)
  }
}
// The key is the one that gets added to the outputs
// as it is the classification which in the context of the application
// is the amount of cars taken

if (outputs.size == 1) {
  return outputs[0]
  // Given the examples above,
  // the output that gets returned is 3
  // which means that for that set of RSSI values
  // there are 3 parking spaces occupied
}
</code></pre>
<p>However, it could be possible for the neighbors to have different classifications,
yet the same amount of points.</p>
<p>For example:
hashmap = {2=1, 3=2, 4=1}</p>
<p>Which is why a tie-breaker is implemented like so:</p>
<pre><code class="language-kt">while (end &gt; 0) {
  end--
  val classification = distances[end].second
  // Decreases the value stored in that classification
  hashmap[classification]?.dec()
  // hashmap = {2=0, 3=1, 4=0}
  // this means that 3 is still the classification that gets returned
  // as it is only classification with the highest value

  max = -1
  outputs.clear()
  for ((key, value) in hashmap) {
    if (value &gt; max) {
      max = value
      outputs.clear()
      outputs.add(key)
    } else if (value == max) {
      outputs.add(key)
    }
  }

  if (outputs.size == 1) {
    return outputs[0]
  }
}
</code></pre>
<p>And if, for some reason all of the neighbors are all the same value like so:
hashmap = {2=1, 3=2, 4=1}</p>
<p>Then the algorithm would return the classification of the nearest neighbor:</p>
<pre><code class="language-kt">return distances[0].second
// distances[0] = (35.0, 3)
// which means that the classification still returned is 3
</code></pre>
<h3 id="loadmatrix"><a class="header" href="#loadmatrix">loadMatrix</a></h3>
<p>The <code>loadMatrix</code> method loads the matrix from an existing database.</p>
<h4 id="snippet-3"><a class="header" href="#snippet-3">Snippet</a></h4>
<pre><code class="language-kt">fun loadMatrix(data: ArrayList&lt;RowData&gt;) {
    inputSize = data.size

    labels.clear()
    matrix.clear()
    for (row in data) {
      labels.add(row.label)
      matrix.add(row.values)
    }

    k = sqrt(matrix.size.toDouble()).toInt()
  }
</code></pre>
<h4 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><code>data: ArrayList&lt;RowData&gt;</code></td><td>A list of <a href="row-data.html">RowData</a> which the matrix gets loaded from.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h4>
<p>The start of the method overwrites the <code>inputSize</code> with the size of the <code>data</code> and clears the existing values of <code>labels</code> and <code>matrix</code>.</p>
<pre><code class="language-kt">inputSize = data.size

labels.clear()
matrix.clear()
</code></pre>
<p>After clearing the existing values in the database, the values from <code>data</code> gets added into the <code>labels</code> and <code>matrix</code> lists.</p>
<pre><code class="language-kt">// The same as:
// for (i in 0 until data.size){
//     var row = data[i]
//     labels.add(row.label)
//     matrix.add(row.values)
// }
for (row in data){
    labels.add(row.label)
    matrix.add(row.values)
}
</code></pre>
<p>Once the <code>labels</code> and <code>matrix</code> has been loaded from the <code>data</code>, the <code>k</code> value gets updated as well.</p>
<pre><code class="language-kt">k = sqrt(matrix.size.toDouble()).toInt()
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../chapters/projectStructure.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../chapters/models/models.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../chapters/projectStructure.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../chapters/models/models.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
