<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ParkingRSSI Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="chapters/applicationOverview.html">Application Overview</a></li><li class="chapter-item expanded affix "><a href="chapters/algorithmOverview.html">Algorithm Overview</a></li><li class="chapter-item expanded affix "><a href="chapters/projectStructure.html">Project Structure</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapters/scripts/knn-classifier.html"><strong aria-hidden="true">1.</strong> KNN Classifier</a></li><li class="chapter-item expanded "><a href="chapters/models/models.html"><strong aria-hidden="true">2.</strong> Models</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/models/rowdata.html"><strong aria-hidden="true">2.1.</strong> RowData</a></li><li class="chapter-item expanded "><a href="chapters/models/session.html"><strong aria-hidden="true">2.2.</strong> Session</a></li><li class="chapter-item expanded "><a href="chapters/scripts/router.html"><strong aria-hidden="true">2.3.</strong> Router</a></li></ol></li><li class="chapter-item expanded "><a href="chapters/models/singletons.html"><strong aria-hidden="true">3.</strong> Singletons</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/models/prefs.html"><strong aria-hidden="true">3.1.</strong> Prefs</a></li><li class="chapter-item expanded "><a href="chapters/models/dbhelper.html"><strong aria-hidden="true">3.2.</strong> DBHelper</a></li></ol></li><li class="chapter-item expanded "><a href="chapters/views/views.html"><strong aria-hidden="true">4.</strong> Views</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/scripts/main-activity.html"><strong aria-hidden="true">4.1.</strong> Main Activity</a></li><li class="chapter-item expanded "><a href="chapters/views/sessionFragment.html"><strong aria-hidden="true">4.2.</strong> Session Fragment</a></li><li class="chapter-item expanded "><a href="chapters/views/scanRouterFragment.html"><strong aria-hidden="true">4.3.</strong> Scan Router Fragment</a></li><li class="chapter-item expanded "><a href="chapters/views/dataFragment.html"><strong aria-hidden="true">4.4.</strong> Data Fragment</a></li><li class="chapter-item expanded "><a href="chapters/views/homeFragment.html"><strong aria-hidden="true">4.5.</strong> Home Fragment</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ParkingRSSI Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="application-overview"><a class="header" href="#application-overview">Application Overview</a></h1>
<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<p>Before using the app, ensure that the app has the following permissions:</p>
<ul>
<li>Files and media
<ul>
<li>Allow management of all files</li>
</ul>
</li>
<li>Location
<ul>
<li>Allow only while using the app</li>
<li>Use precise location is enabled</li>
</ul>
</li>
</ul>
<p>The Files and media permissions is for allowing the app to save data to the device,
while the Location permissions are for detecting the Wi-Fi signals.</p>
<h2 id="adding-a-session"><a class="header" href="#adding-a-session">Adding a session</a></h2>
<p>Upon opening the app for the first time, you will be greeted by the <code>Session</code> page.
The <code>Session</code> page is where we can access the different configurations for training the model.</p>
<p><img src="https://i.imgur.com/ngLLRET.jpg" alt="" /></p>
<p>By adding a session, we can now navigate the other pages.</p>
<p><img src="https://i.imgur.com/l8ZwO2r.gif" alt="" /></p>
<h2 id="setting-up-the-routers"><a class="header" href="#setting-up-the-routers">Setting up the routers</a></h2>
<p>Once a session has been made, we can now visit the other pages of the app.
However, in order to use the app, the routers must first be setup in the <code>Routers</code> page.</p>
<p><img src="https://i.imgur.com/wVnDrbz.jpg" alt="" /></p>
<p>By default, the router matrix is set to a 2x3 configuration but this is only for visualization purposes
and has no bearing on how the results will be calculated.</p>
<p>In order to setup the routers:</p>
<ul>
<li>Adjust the router matrix</li>
<li>Scan for the routers</li>
<li>Select which entry in the matrix a router is to be set</li>
<li>Select the appropriate router</li>
</ul>
<p><img src="https://i.imgur.com/c7LkFbS.gif" alt="" /></p>
<h2 id="recording-a-point"><a class="header" href="#recording-a-point">Recording a point</a></h2>
<p>After the routers have been setup, we can now record a point by going to the <code>Home</code> page.
Put simply, a <code>point</code> is the amount of cars taken and the corresponding RSSI values at that moment.</p>
<p><img src="https://i.imgur.com/Pu5vTez.jpg" alt="" /></p>
<p>In the <code>Home</code> page, there are two input fields wherein numbers can be assigned.
The first one is for the <strong>total amount of parking spaces</strong>
and the second one is for the <strong>total amount of occupied spaces in the current setup</strong>.</p>
<p>In order to record a point:</p>
<ul>
<li>Enter the total amount of occupied spaces</li>
<li>Press record</li>
</ul>
<p><img src="https://i.imgur.com/93kO9tl.gif" alt="" /></p>
<p>There will be a delay before the app would say that the scan is complete,
then you can go to the <code>Data</code> page in order to view the entry.</p>
<p><img src="https://i.imgur.com/k9FiQ30.jpg" alt="" /></p>
<h2 id="predicting-the-amount"><a class="header" href="#predicting-the-amount">Predicting the amount</a></h2>
<p>Once a sufficient number of points have been recorded, the number of cars can now be predicted.</p>
<p>In order to predict the number of cars:</p>
<ul>
<li>Ensure that the routers are connected properly</li>
<li>Adjust the total amount of parking spaces if necessary</li>
<li>Press predict</li>
</ul>
<p><img src="https://i.imgur.com/F1uxKLh.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithm-overview"><a class="header" href="#algorithm-overview">Algorithm Overview</a></h1>
<p>This Smart Parking System uses the K-Nearest Neighbors (KNN) algorithm in order to calculate the amount of available parking spaces
using Received Signal Strength Indicator (RSSI) values.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<h3 id="plotting-the-points"><a class="header" href="#plotting-the-points">Plotting the points</a></h3>
<p>In this program, the K-Nearest Neighbors (KNN) algorithm is implemented by collecting the Received Signal Strength Indicator (RSSI) values
of a parking lot with a set amount of cars. This can be visualized in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>Number of Cars</th><th>RSSI Values</th></tr></thead><tbody>
<tr><td>0</td><td>-30.0, -27.0</td></tr>
<tr><td>1</td><td>-22.0, -27.0</td></tr>
<tr><td>1</td><td>-26.0, -24.0</td></tr>
<tr><td>1</td><td>-29.0, -25.0</td></tr>
<tr><td>1</td><td>-32.0, -23.0</td></tr>
</tbody></table>
</div>
<p>And this is how it can be seen in a graph:</p>
<p><img src="https://i.imgur.com/nZFeIgk.png" alt="" /></p>
<p>When the app is used to check how many parking spaces are still available, it compares the current RSSI values to the existing data.</p>
<p>Let us say for example that we used the app and got the following data:</p>
<div class="table-wrapper"><table><thead><tr><th>Number of Cars</th><th>RSSI Values</th></tr></thead><tbody>
<tr><td>?</td><td>-30.0, -22.0</td></tr>
</tbody></table>
</div>
<p>And in a graph, it appears like this in accordance with the existing data:</p>
<p><img src="https://i.imgur.com/OpzUjGu.png" alt="" /></p>
<h3 id="the-k-value"><a class="header" href="#the-k-value">The k-value</a></h3>
<p>Now that we have our point, this is where the value of <code>k</code> comes into place. <code>k</code> is the number of neighboring points we compare to in order to
classify our point. Remember that each category is the amount of cars for that set of RSSI values.</p>
<blockquote>
<p>By default, the value of <code>k</code> in the program is 3. This means that the algorithm only compares the current point to 3 neighboring points.
Increasing the value of <code>k</code> is better for accuracy, at the cost of speed.
In this example, the classification of the point has changed depending on the value of the <code>k</code>:
<img src="https://helloacm.com/wp-content/uploads/2016/03/2012-10-26-knn-concept.png" alt="" /></p>
</blockquote>
<h3 id="getting-the-nearest-points"><a class="header" href="#getting-the-nearest-points">Getting the nearest points</a></h3>
<p>Now that we have our k value, it is time to get our nearest neighbors.
In order to get the distance from the current point to the neighboring points, the program uses the Euclidean Distance formula:</p>
<p>\[ d(p,q) = \sqrt {\sum_{i=1}^n (q_i - p_i)^2}  \]</p>
<p>where:</p>
<ul>
<li>\(p, q\) = two points in Euclidean n-space</li>
<li>\(q_i, p_i\) = Euclidean vectors, starting from the origin of the space (initial point)</li>
<li>\(n\) = n-space</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> If this looks complex, it is similar to calculating the length of the hypothenuse in a triangle (Pythagorean Theorem).
\[hypothenuse = \sqrt{{leg_1}^2 + {leg_2}^2}\]
I recommend studying more Vector maths in order to get a better understanding of Euclidean Distance.</p>
</blockquote>
<p>In our program, calculating the distances can be visualized as such in accordance with the existing data:</p>
<ul>
<li>\(p\) = coordinates of the current point</li>
<li>\(q\) = coordinates of the point of a neighbor. I will be using the amount of cars as the label for clarity.</li>
<li>\(d\) = distance between our points</li>
</ul>
<blockquote>
<p>Do take note that adding more routers would only mean adding more rows to the table,
however it would be more difficult to visualize in a 2D graph like the ones presented in this document.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (0)</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-30.0</td><td>\(\sqrt{(-30.0 + 30.0)^2}\)</td><td>0</td></tr>
<tr><td>-22.0</td><td>-27.0</td><td>\(\sqrt{(-27.0 + 22.0)^2}\)</td><td>5</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_0 = 0 + 5 = 5\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_0\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-22.0</td><td>\(\sqrt{(-22.0 + 30.0)^2}\)</td><td>8</td></tr>
<tr><td>-22.0</td><td>-27.0</td><td>\(\sqrt{(-27.0 + 22.0)^2}\)</td><td>5</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_1 = 8 + 5 = 13\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_1\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-26.0</td><td>\(\sqrt{(-26.0 + 30.0)^2}\)</td><td>4</td></tr>
<tr><td>-22.0</td><td>-24.0</td><td>\(\sqrt{(-24.0 + 22.0)^2}\)</td><td>2</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_2 = 4 + 2 = 6\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_2\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-29.0</td><td>\(\sqrt{(-29.0 + 30.0)^2}\)</td><td>1</td></tr>
<tr><td>-22.0</td><td>-25.0</td><td>\(\sqrt{(-25.0 + 22.0)^2}\)</td><td>3</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_3 = 1 + 3 = 4\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_3\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-32.0</td><td>\(\sqrt{(-32.0 + 30.0)^2}\)</td><td>2</td></tr>
<tr><td>-22.0</td><td>-23.0</td><td>\(\sqrt{(-23.0 + 22.0)^2}\)</td><td>1</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_4 = 2 + 1 = 3\]</p>
<p>After we calculate the distances for each point, we can visualize them like so:</p>
<div class="table-wrapper"><table><thead><tr><th>Amount of Cars</th><th>Index</th><th>Distance</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>5</td></tr>
<tr><td>1</td><td>1</td><td>13</td></tr>
<tr><td>1</td><td>2</td><td>6</td></tr>
<tr><td>1</td><td>3</td><td>4</td></tr>
<tr><td>1</td><td>4</td><td>3</td></tr>
</tbody></table>
</div>
<p>At this point, we only have the distances to other points, but we do not know yet the nearest neighbors.
In order to get the nearest neighbors, all we need to do is to sort the distances like so:</p>
<div class="table-wrapper"><table><thead><tr><th>Amount of Cars</th><th>Index</th><th>Distance</th></tr></thead><tbody>
<tr><td>1</td><td>4</td><td>3</td></tr>
<tr><td>1</td><td>3</td><td>4</td></tr>
<tr><td>0</td><td>0</td><td>5</td></tr>
<tr><td>1</td><td>2</td><td>6</td></tr>
<tr><td>1</td><td>1</td><td>13</td></tr>
</tbody></table>
</div>
<p>Now that the distances have been sorted, the nearest neighbors can now be gathered in accordance with the <code>k</code> value.
Since the default of <code>k</code> is 3, the nearest points would be the following:</p>
<div class="table-wrapper"><table><thead><tr><th>Amount of Cars</th><th>Index</th><th>Distance</th><th>RSSI Values</th></tr></thead><tbody>
<tr><td>1</td><td>4</td><td>3</td><td>-32.0, -23.0</td></tr>
<tr><td>1</td><td>3</td><td>4</td><td>-29.0, -25.0</td></tr>
<tr><td>0</td><td>0</td><td>5</td><td>-30.0, -27.0</td></tr>
</tbody></table>
</div>
<p>In a graph, it can be visualized like so:
<img src="https://i.imgur.com/b7MSijK.png" alt="" /></p>
<p>Because there is only 1 point that has zero cars, and 2 points that have one car,
according to the KNN algorithm, the RSSI values of the current point (-30, -22) would state that
there is 1 parking slot occupied.</p>
<p><img src="https://i.imgur.com/O8n6Szo.png" alt="" /></p>
<p>This means that in a parking lot of 10 slots, there is 1 occupied slot and 9 available slots.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>The project consists of two major components, the source code and the layout files.
Source code files end in <code>.kt</code> while layout files end in <code>.xml</code>.
Source code files are responsible for the logic of the app
while layout files are responsible for the interface.</p>
<h2 id="source-code-directories"><a class="header" href="#source-code-directories">Source Code Directories</a></h2>
<p>When the project is opened in Android Studio, there is a file explorer located in the left portion of the screen by default named <code>Project</code>.
Ensure that <code>Android</code> is selected on the tab on the top as it is a simple layout to navigate.
Under <code>app</code>, expand the <code>java</code> folder, and <code>com.silentrald.parkingrssi</code>.
All the files inside this folder contains the source code for the project.</p>
<p><img src="https://i.imgur.com/gmHlPxZ.gif" alt="" /></p>
<h3 id="descriptions"><a class="header" href="#descriptions">Descriptions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Folder</th><th>File</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>interfaces</strong></td><td></td><td>Contains <a href="https://kotlinlang.org/docs/interfaces.html">interfaces</a> which will be used by the other classes.</td></tr>
<tr><td></td><td>CellClickListener</td><td></td></tr>
<tr><td><strong>models</strong></td><td></td><td>Contains the <a href="https://kotlinlang.org/docs/classes.html">classes</a> needed by the program to create and train the model for the neural network.</td></tr>
<tr><td></td><td>DBHelper</td><td>Contains methods in order to create an <a href="https://www.geeksforgeeks.org/android-sqlite-database-in-kotlin/"><code>SQLite Database</code></a> for recording information about the routers and sessions.</td></tr>
<tr><td></td><td>Prefs</td><td>Contains information to save the session and capacity to the device.</td></tr>
<tr><td></td><td>RowData</td><td>Contains the number of cars occupied for a set of RSSI values.</td></tr>
<tr><td></td><td>Session</td><td>Contains the setup of how the model is trained.</td></tr>
<tr><td><strong>views</strong></td><td></td><td>Contains the classes to interact with the different screens of the application.</td></tr>
<tr><td></td><td>DataFormDialog</td><td></td></tr>
<tr><td></td><td>DataFragment</td><td></td></tr>
<tr><td></td><td>HomeFragment</td><td></td></tr>
<tr><td></td><td>RecyclerViewAdapter</td><td></td></tr>
<tr><td></td><td>ScanRouterFragment</td><td></td></tr>
<tr><td></td><td>SessionFragment</td><td></td></tr>
<tr><td><strong>-</strong></td><td></td><td>The classes found on the root of <code>com.silentrald.parkingrssi</code></td></tr>
<tr><td></td><td>KNNClassifier</td><td>Contains the logic implementing the <a href="https://bit.ly/2OcMqHv">K-Nearest Neighbor Algorithm</a>.</td></tr>
<tr><td></td><td>MainActivity</td><td>Controls the navigation of the program.</td></tr>
<tr><td></td><td>Router</td><td>Contains methods in order for the program to view and record routers.</td></tr>
</tbody></table>
</div>
<h2 id="layout-directories"><a class="header" href="#layout-directories">Layout Directories</a></h2>
<p>The layout directories contain the files that create the user interface of the application.
It also contains the ids of each component which would be used by the scripts in the <code>views</code> directory.
The layouts are stored in <code>app &gt; res &gt; layout</code>.</p>
<p><img src="https://i.imgur.com/0NBqEqH.png" alt="" /></p>
<h3 id="descriptions-1"><a class="header" href="#descriptions-1">Descriptions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>File</th><th>Description</th></tr></thead><tbody>
<tr><td>activity_main.xml</td><td>Contains a navigation bar and where the fragment gets displayed.</td></tr>
<tr><td>fragment_data.xml</td><td>Contains a list of recordings of the RSSI values and buttons to import and export csv files.</td></tr>
<tr><td>fragment_home.xml</td><td>Contains the interface needed to train the model and predict the amount of vehicles in the parking slot.</td></tr>
<tr><td>fragment_scan_router.xml</td><td>Contains a menu to select the routers to be recorded.</td></tr>
<tr><td>fragment_session.xml</td><td>Contains a list of sessions to be loaded.</td></tr>
<tr><td>layout_data_form.xml</td><td></td></tr>
<tr><td>layout_data_row.xml</td><td></td></tr>
<tr><td>layout_data_value_input.xml</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="knn-classifier"><a class="header" href="#knn-classifier">KNN Classifier</a></h1>
<p>The <code>KNN Classifier</code> class contains the logic implementing the <a href="https://bit.ly/2OcMqHv">K-Nearest Neighbor Algorithm</a>.
It is located at <code>app &gt; java &gt; com.silentrald.parkingrssi &gt; KNNClassifier.kt</code>.
This page is for explaining the source code of how the algorithm is implemented.
For a more high level overview, please refer to the <a href="chapters/scripts/algorithmOverview.html">Algorithm Overview</a>.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>The <code>KNN Classifier</code> class has multiple fields which are needed in order to calculate the number of available parking spaces
using the algorithm.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>k</td><td><code>var k: Int = 3</code></td><td>The number of neighbors to be evaluated by the algorithm. The value is set to 3 by default.</td></tr>
<tr><td>inputSize</td><td><code>var inputSize: Int = 6</code></td><td>The number of routers to get RSSI values from.</td></tr>
<tr><td>matrix</td><td><code>val matrix = arrayListOf&lt;ArrayList&lt;Float&gt;&gt;()</code></td><td>A collection of RSSI values gathered from the routers.</td></tr>
<tr><td>labels</td><td><code>val labels = arrayListOf&lt;Int&gt;()</code></td><td>A collection of the amount of cars for a set of RSSI values.</td></tr>
</tbody></table>
</div>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="addpoint"><a class="header" href="#addpoint">addPoint</a></h3>
<p>The <code>addPoint</code> method adds a point to the dataset. This point contains the RSSI values and the amount of cars for that set.</p>
<h4 id="snippet"><a class="header" href="#snippet">Snippet</a></h4>
<pre><code class="language-kt">fun addPoint(point: ArrayList&lt;Float&gt;, label: Int) {
    if (point.size != inputSize) {
      return
    }

    matrix.add(point)
    labels.add(label)

    k = sqrt(matrix.size.toDouble()).toInt()
  }
</code></pre>
<h4 id="parameters"><a class="header" href="#parameters">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>point</td><td><code>point: ArrayList&lt;Float&gt;</code></td><td>The RSSI values received from the routers.</td></tr>
<tr><td>label</td><td><code>label: Int</code></td><td>The amount of cars in the parking lot when the point is recorded.</td></tr>
</tbody></table>
</div>
<h4 id="implementation"><a class="header" href="#implementation">Implementation</a></h4>
<p>At the start of the method, the size of the point is compared to the <code>inputSize</code>.
Each router sends a single RSSI value which is contained as a list in the <code>point</code> variable.
This check then is to ensure that all routers have sent an RSSI value before it is added to the database.</p>
<pre><code class="language-kt">// For example:
// point = {-27.0,-36.0,-20.0,-27.0,-31.0}

// Given that there are 5 entries in point:
// point.size = 5

// inputSize is based on the amount of routers selected.
// Given that each router sends a single RSSI value:
// inputSize = 5

// Because the point.size and inputSize is the same
// the method would not return and continue to the next step

if (point.size != inputSize){
    return
}
</code></pre>
<p>If the <code>point</code> entered is valid, it gets added to the <code>matrix</code> and the <code>label</code> gets added to the <code>labels</code>.
In essence, this &quot;pairs&quot; the <code>label</code> with the <code>point</code> entered as they share the same index as they get added to their lists at the same time.</p>
<pre><code class="language-kt">// For example:
// point = {-27.0,-36.0,-20.0,-27.0,-31.0}
// label = 0
// matrix = {}
// labels = {}

// The reason matrix is empty is because there are no points added to it yet.
// labels is empty for the same reason.

matrix.add(point)

// matrix = [{-27.0,-36.0,-20.0,-27.0,-31.0}]

// After adding the point, the matrix now contains the list of RSSI values from the point.
// This is why in the declaration of the matrix, it is an arrayListof&lt;ArrayList&lt;Float&gt;&gt;()
// The matrix is a list for a list of float variables.

labels.add(label)

// labels = {0}

// After adding the label, the labels list now contain the value of the label.
</code></pre>
<p>Once the <code>point</code> and <code>label</code> has been added to the database, the value of <code>k</code> is adjusted.</p>
<pre><code class="language-kt">// For example, another point has been added to the matrix:
// matrix = [{-27.0,-36.0,-20.0,-27.0,-31.0}, -26.0,-37.0,-20.0,-28.0,-30.0}]
// matrix.size = 2
// matrix.size.toDouble = 2.0
// sqrt(matrix.size.toDouble()) = 1.41421356237309511.0
// sqrt(matrix.size.toDouble()).toInt() = 1

k = sqrt(matrix.size.toDouble()).toInt()

// By doing this, the points gets compared to more neighbors as it increases.
</code></pre>
<p>As mentioned before, this &quot;pairs&quot; the <code>point</code> and <code>label</code> together.
For example, the data collected from five routers can be presented in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>label</th><th>66852627208993-xiaomi-repeater-v3_miapdb21</th><th>66852627204643-xiaomi-repeater-v3_miapca23</th><th>66852627209260-xiaomi-repeater-v3_miapdc2c</th><th>66852627198541-xiaomi-repeater-v3_miapb24d</th><th>66852627208795-xiaomi-repeater-v3_miapda5b</th></tr></thead><tbody>
<tr><td>0</td><td>-27.0</td><td>-36.0</td><td>-20.0</td><td>-27.0</td><td>-31.0</td></tr>
<tr><td>1</td><td>-26.0</td><td>-37.0</td><td>-20.0</td><td>-28.0</td><td>-30.0</td></tr>
<tr><td>2</td><td>-25.0</td><td>-43.0</td><td>-18.0</td><td>-29.0</td><td>-31.0</td></tr>
<tr><td>3</td><td>-26.0</td><td>-39.0</td><td>-21.0</td><td>-27.0</td><td>-32.0</td></tr>
<tr><td>4</td><td>-26.0</td><td>-39.0</td><td>-24.0</td><td>-25.0</td><td>-31.0</td></tr>
<tr><td>5</td><td>-25.0</td><td>-41.0</td><td>-25.0</td><td>-23.0</td><td>-31.0</td></tr>
</tbody></table>
</div>
<p>However, in the code these data are stored in two different lists, the <code>matrix</code> and <code>labels</code>, and they can be represented like so:</p>
<pre><code class="language-json">[
  {
    &quot;labels&quot;: &quot;{0,1,2,3,4,5}&quot;,
    &quot;matrix&quot;: &quot;{-27.0,-36.0,-20.0,-27.0,-31.0},{-26.0,-37.0,-20.0,-28.0,-30.0},{-25.0,-43.0,-18.0,-29.0,-31.0},{-26.0,-39.0,-21.0,-27.0,-32.0},{-26.0,-39.0,-24.0,-25.0,-31.0},{-25.0,-41.0,-25.0,-23.0,-31.0}&quot;
  }
]
</code></pre>
<p>Or in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>labels</th><th>matrix</th></tr></thead><tbody>
<tr><td>0</td><td>{-27.0,-36.0,-20.0,-27.0,-31.0}</td></tr>
<tr><td>1</td><td>{-26.0,-37.0,-20.0,-28.0,-30.0}</td></tr>
<tr><td>2</td><td>{-25.0,-43.0,-18.0,-29.0,-31.0}</td></tr>
<tr><td>3</td><td>{-26.0,-39.0,-21.0,-27.0,-32.0}</td></tr>
<tr><td>4</td><td>{-26.0,-39.0,-24.0,-25.0,-31.0}</td></tr>
<tr><td>5</td><td>{-25.0,-41.0,-25.0,-23.0,-31.0}</td></tr>
</tbody></table>
</div>
<h3 id="calculatedistance"><a class="header" href="#calculatedistance">calculateDistance</a></h3>
<p>The <code>calculateDistance</code> method aggregates the distance between two collections of RSSI values.
In the app, one collection is from the current RSSI values received by the device
and another is from the existing RSSI values added to the <code>matrix</code>.
This is because the <code>calculateDistance</code> method is used when the app is <a href="chapters/scripts/knn-classifier.html#predict">predicting</a>.</p>
<p>It helps to think of each collection of RSSI values as a coordinate, however as the number of routers increase
so too does the dimensions in which these coordinates exist, which is why the Euclidean Distance formula is used to
calculate the distance between each point.</p>
<blockquote>
<p><strong>NOTE:</strong>
For a further in-depth breakdown of the usage of the Euclidean Distance formula,
please refer to the <a href="chapters/scripts/algorithmOverview.html#getting-the-nearest-points">Getting the nearest points</a>
section in the Algorithm Overview.</p>
</blockquote>
<h4 id="snippet-1"><a class="header" href="#snippet-1">Snippet</a></h4>
<pre><code class="language-kt">private fun calculateDistance(ps1: ArrayList&lt;Float&gt;, ps2: ArrayList&lt;Float&gt;): Float {
    if (ps1.size != ps2.size) return -1f

    var distance = 0f
    for (i in 0 until ps1.size) {
      distance += (ps1[i] - ps2[i]).pow(2) // (x1 - x2) ^ 2
    }
    return distance
  }
</code></pre>
<h4 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>ps1</td><td><code>ps1: ArrayList&lt;Float&gt;</code></td><td>The current RSSI values being detected by the device.</td></tr>
<tr><td>ps2</td><td><code>ps2: ArrayList&lt;Float&gt;</code></td><td>The RSSI values from the <code>matrix</code>.</td></tr>
</tbody></table>
</div>
<h4 id="returns"><a class="header" href="#returns">Returns</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Returns</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>distance</td><td><code>Float</code></td><td>The aggregated distance between the two collections of RSSI values.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h4>
<pre><code class="language-kt">// Compare the sizes of the parameters to check if it is valid.
// Returning a negative distance would mean that the parameters are invalid.
if(ps1.size != ps2.size) return -1f

// The next line creates a variable distance.
// This is where the aggregated distances will be stored and returned.
var distance = 0f

// The next line states that until the index reaches the size of ps1,
// the Euclidean Distance of the two points would be added to distance.
for (i in 0 until ps1.size){
    distance += (ps1[i] - ps2[i]).pow(2)
}

// Once the loop is finished, the distance would be returned.
return distance
</code></pre>
<p>Let us say for example that we are working with the following data:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>ps1</th><th>ps2</th></tr></thead><tbody>
<tr><td>0</td><td>-27.0</td><td>-26.0</td></tr>
<tr><td>1</td><td>-36.0</td><td>-37.0</td></tr>
<tr><td>2</td><td>-20.0</td><td>-20.0</td></tr>
<tr><td>3</td><td>-27.0</td><td>-28.0</td></tr>
<tr><td>4</td><td>-31.0</td><td>-30.0</td></tr>
</tbody></table>
</div>
<p>When we use the function, we first check if the size of both lists are the same.</p>
<pre><code class="language-kt">if(ps1.size != ps2.size) return -1f
</code></pre>
<p>This means that if we use the data given above, we would not return <code>-1f</code> because both lists have 5 items in them,
however if ps1 or ps2 does not have the same number of items, we would return <code>-1f</code> and we would not calculate the distances between those points
because the given list of points are invalid.
The reason we are returning <code>-1f</code> is because the function requires a number to be returned which is the <code>distance</code>, therefore, if we return a negative distance,
this means that there has been an error in processing the given points.</p>
<p>Afterwards, the distance is computed by going through each item in the lists and aggregating their distances.</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>ps1</th><th>ps2</th><th>distance</th><th>\[\sum_{i=0}^{ps1.size} {distance}\]</th></tr></thead><tbody>
<tr><td>0</td><td>-27.0</td><td>-26.0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>-36.0</td><td>-37.0</td><td>1</td><td>2</td></tr>
<tr><td>2</td><td>-20.0</td><td>-20.0</td><td>0</td><td>2</td></tr>
<tr><td>3</td><td>-27.0</td><td>-28.0</td><td>1</td><td>3</td></tr>
<tr><td>4</td><td>-31.0</td><td>-30.0</td><td>1</td><td>4</td></tr>
</tbody></table>
</div>
<p>After this loop has been finished, we have arrived at the distance of <code>4</code>,
which means the calculated distance that will be returned form the function will be <code>4</code>.</p>
<h3 id="predict"><a class="header" href="#predict">predict</a></h3>
<p>The <code>predict</code> method is where the actual implementation of the K-Nearest Neighbor algorithm as it predicts
the amount of cars taken with the <code>point</code> given to it.</p>
<h4 id="snippet-2"><a class="header" href="#snippet-2">Snippet</a></h4>
<pre><code class="language-kt">fun predict(point: ArrayList&lt;Float&gt;): Int {
    val distances = arrayListOf&lt;Pair&lt;Float, Int&gt;&gt;()
    for (i in 0 until matrix.size) {
      distances.add(Pair(calculateDistance(point, matrix[i]), labels[i]))
    }

    distances.sortWith(compareBy { it.first })
    Log.i(&quot;KNN&quot;, distances.toString())

    val hashmap = hashMapOf&lt;Int, Int&gt;()

    var end = k.coerceAtMost(matrix.size)
    for (i in 0 until end) {
      val classification = distances[i].second
      hashmap[classification] = hashmap.getOrDefault(classification, 0) + 1
    }

    // Get Max (Plurality)
    var max = -1
    val outputs = arrayListOf&lt;Int&gt;()
    for ((key, value) in hashmap) {
      if (value &gt; max) {
        max = value
        outputs.clear()
        outputs.add(key)
      } else if (value == max) {
        outputs.add(key)
      }
    }

    if (outputs.size == 1) {
      return outputs[0]
    }

    // Tie-breaking
    while (end &gt; 0) {
      end--
      val classification = distances[end].second
      hashmap[classification]?.dec()

      max = -1
      outputs.clear()
      for ((key, value) in hashmap) {
        if (value &gt; max) {
          max = value
          outputs.clear()
          outputs.add(key)
        } else if (value == max) {
          outputs.add(key)
        }
      }

      if (outputs.size == 1) {
        return outputs[0]
      }
    }

    // Just return the first one
    return distances[0].second
  }
</code></pre>
<h4 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>point</td><td><code>ArrayList&lt;Float&gt;</code></td><td>The current RSSI values being detected by the device.</td></tr>
</tbody></table>
</div>
<h4 id="returns-1"><a class="header" href="#returns-1">Returns</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Returns</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>outputs[0]</td><td><code>Int</code></td><td>The largest <code>label</code> recorded in the database.</td></tr>
<tr><td>distances[0].second</td><td><code>Int</code></td><td>The <code>label</code> of the nearest neighbor to the <code>point</code>.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h4>
<p>At the start of the <code>predict</code> method, a List of a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/"><code>Pair</code></a>
of types <code>Float</code> and <code>Int</code> are created and stored in the variable <code>distances</code>.
The <code>Float</code> is responsible for containing the distance from the <code>point</code> to the existing points added in the database,
while the <code>Int</code> contains the amount of cars expected for the point according to the database.</p>
<pre><code class="language-kt">val distances = arrayListOf&lt;Pair&lt;Float, Int&gt;&gt;()

for (i in 0 until matrix.size){
  distances.add(Pair(calculateDistance(point,matrix[i]), labels[i]))
}
</code></pre>
<p>For example, the given data is the following:</p>
<pre><code>label = {2,3,4}
matrix = [
  {-25.0,-43.0,-18.0,-29.0,-31.0},
  {-26.0,-39.0,-21.0,-27.0,-32.0},
  {-26.0,-39.0,-24.0,-25.0,-31.0}
  ]
point = {-26.0,-35.0,-21.0,-26.0,-27.0}
</code></pre>
<p>When graphed into a table, it would look like the following:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>labels[i]</th><th>matrix[i]</th><th>point</th></tr></thead><tbody>
<tr><td>0</td><td>2</td><td>-25.0,-43.0,-18.0,-29.0,-31.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
<tr><td>1</td><td>3</td><td>-26.0,-39.0,-21.0,-27.0,-32.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
<tr><td>2</td><td>4</td><td>-26.0,-39.0,-24.0,-25.0,-31.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
</tbody></table>
</div>
<p>When the distances are calculated and paired, we get the following result:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>Pair(calculateDistance,labels[i])</th></tr></thead><tbody>
<tr><td>0</td><td>(98.0, 2)</td></tr>
<tr><td>1</td><td>(41.0, 3)</td></tr>
<tr><td>2</td><td>(41.0, 4)</td></tr>
</tbody></table>
</div>
<p>After calculating the <code>distances</code>, it is sorted according to the calculated distance which is the <code>first</code> item in the pair.</p>
<pre><code class="language-kt">distances.sortWith(compareBy {it.first})
</code></pre>
<p>Once sorted, the <code>distances</code> is now the following:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>Pair(calculateDistance,labels[i])</th></tr></thead><tbody>
<tr><td>0</td><td>(41.0, 3)</td></tr>
<tr><td>1</td><td>(41.0, 4)</td></tr>
<tr><td>2</td><td>(98.0, 2)</td></tr>
</tbody></table>
</div>
<p>After sorting the <code>distances</code>, a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-map/"><code>hashmap</code></a>
is created in order to store the amount of neighbors for each classification (the number of cars or label).</p>
<p>For example:</p>
<blockquote>
<p><strong>NOTE:</strong> Additional data has been added in order to provide a more clear example.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>distances</th><th>label</th></tr></thead><tbody>
<tr><td>0</td><td>35.0</td><td>3</td></tr>
<tr><td>1</td><td>41.0</td><td>3</td></tr>
<tr><td>2</td><td>41.0</td><td>4</td></tr>
<tr><td>3</td><td>98.0</td><td>2</td></tr>
</tbody></table>
</div>
<p>When the data is stored into the hashmap, it can be seen like so:</p>
<pre><code class="language-kt">val hashmap = hashMapOf&lt;Int, Int&gt;()
// hashmap = {}

var end = k.coerceAtMost(matrix.size)
// matrix.size = 4
// since k = sqrt(matrix.size.toDouble()).toInt()
// k = 2 for this example
// therefore, end = 2

for (i in 0 until end){
  val classification = distances[i].second
  // In the pair, distance[0] = (35.0, 3)
  // By getting the second value in the pair
  // classification = 3

  hashmap[classification] = hashmap.getOrDefault(classification, 0)+1
  // hashmaps are similar to pairs, but they function differently.
  // hashmaps are key, value pairs
  // wherein the first element is the key and the second element is the value.
  // keys can be used as an index and they can store a value isolated from the items in the hashmap

  // in the line above, hashmap[classification] sets a value that gets paired to the classification
  // which in the case of the current i (0) is 3
  // So when it is visualized
  // hashmap = {3=null}
  // when hashmap.getOrDefault(classification, 0)+1 gets called
  // the value paired(null) to the classification(3) either gets set to
  // a number or set to the default value of 0 then incremented by 1
  // since the current value is null, it is set to 0 then incremented by 1
  // so after the first iteration hashmap = {3=1}

  // since this is in a loop until the end(2) is reached
  // the next iteration has the current values:
  // distance[1] = (41.0, 3)
  // classification = 3
  
  // now when hashmap.getOrDefault is ran,
  // hashmap[3] is already equal to 1 due to the previous iteration
  // so in this iteration, the value of hashmap[3] is incremented
  // hashmap = {3=2}
}
</code></pre>
<p>Due to the limitation set on the <code>k</code> value, the algorithm only had a single classification,
but if we are to go through all of the labels in <code>distances</code>, the hashmap would have the following value</p>
<pre><code class="language-kt">hashmap = {2=1, 3=2, 4=1}
</code></pre>
<p>These means that for the current point,
it has one neighbor classified as 2,
two neighbors classified as 3,
and one neighbor classified as 4.</p>
<p>After classifying the neighbors, the most number of neighbors of the same classification must be returned,
which is retrieved by the following lines of code:</p>
<pre><code class="language-kt">// set to -1 as the values of the hashmap
// would always be greater than this
var max = -1
// created to contain the classification
// of the greatest amount of neighbors
val outputs = arrayListOf&lt;Int&gt;()
for ((key, value) in hashmap) {
  if (value &gt; max) {
    max = value
    outputs.clear()
    outputs.add(key)
  } else if (value == max) {
    outputs.add(key)
  }
}
// The key is the one that gets added to the outputs
// as it is the classification which in the context of the application
// is the amount of cars taken

if (outputs.size == 1) {
  return outputs[0]
  // Given the examples above,
  // the output that gets returned is 3
  // which means that for that set of RSSI values
  // there are 3 parking spaces occupied
}
</code></pre>
<p>However, it could be possible for the neighbors to have different classifications,
yet the same amount of points.</p>
<p>For example:
hashmap = {2=1, 3=2, 4=1}</p>
<p>Which is why a tie-breaker is implemented like so:</p>
<pre><code class="language-kt">while (end &gt; 0) {
  end--
  val classification = distances[end].second
  // Decreases the value stored in that classification
  hashmap[classification]?.dec()
  // hashmap = {2=0, 3=1, 4=0}
  // this means that 3 is still the classification that gets returned
  // as it is only classification with the highest value

  max = -1
  outputs.clear()
  for ((key, value) in hashmap) {
    if (value &gt; max) {
      max = value
      outputs.clear()
      outputs.add(key)
    } else if (value == max) {
      outputs.add(key)
    }
  }

  if (outputs.size == 1) {
    return outputs[0]
  }
}
</code></pre>
<p>And if, for some reason all of the neighbors are all the same value like so:
hashmap = {2=1, 3=2, 4=1}</p>
<p>Then the algorithm would return the classification of the nearest neighbor:</p>
<pre><code class="language-kt">return distances[0].second
// distances[0] = (35.0, 3)
// which means that the classification still returned is 3
</code></pre>
<h3 id="loadmatrix"><a class="header" href="#loadmatrix">loadMatrix</a></h3>
<p>The <code>loadMatrix</code> method loads the matrix from an existing database.</p>
<h4 id="snippet-3"><a class="header" href="#snippet-3">Snippet</a></h4>
<pre><code class="language-kt">fun loadMatrix(data: ArrayList&lt;RowData&gt;) {
    inputSize = data.size

    labels.clear()
    matrix.clear()
    for (row in data) {
      labels.add(row.label)
      matrix.add(row.values)
    }

    k = sqrt(matrix.size.toDouble()).toInt()
  }
</code></pre>
<h4 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><code>data: ArrayList&lt;RowData&gt;</code></td><td>A list of <a href="chapters/scripts/row-data.html">RowData</a> which the matrix gets loaded from.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h4>
<p>The start of the method overwrites the <code>inputSize</code> with the size of the <code>data</code> and clears the existing values of <code>labels</code> and <code>matrix</code>.</p>
<pre><code class="language-kt">inputSize = data.size

labels.clear()
matrix.clear()
</code></pre>
<p>After clearing the existing values in the database, the values from <code>data</code> gets added into the <code>labels</code> and <code>matrix</code> lists.</p>
<pre><code class="language-kt">// The same as:
// for (i in 0 until data.size){
//     var row = data[i]
//     labels.add(row.label)
//     matrix.add(row.values)
// }
for (row in data){
    labels.add(row.label)
    matrix.add(row.values)
}
</code></pre>
<p>Once the <code>labels</code> and <code>matrix</code> has been loaded from the <code>data</code>, the <code>k</code> value gets updated as well.</p>
<pre><code class="language-kt">k = sqrt(matrix.size.toDouble()).toInt()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="models"><a class="header" href="#models">Models</a></h1>
<p>Models are classes which are used to store and manage data.
Unlike the <a href="chapters/models/../scripts/knn-classifier.html"><code>KNN Classifier</code></a> class,
models rarely hold any logic and algorithms within them.
This is because these classes are used to containerize data
so that it can be easily accessed somewhere else.</p>
<p>Take for example the <a href="chapters/models/session.html"><code>Session</code></a> class:</p>
<pre><code class="language-kt">class Session(
	val id: Long,
	var name: String,
	var rows: Int,
	var cols: Int
) {
	override fun toString(): String {
		return &quot;Id: $id; Name: $name; Rows: $rows; Cols: $cols\n&quot;
	}
}
</code></pre>
<p>In the <a href="chapters/models/../views/sessionFragment.html"><code>Session Fragment</code></a> view,
an instance of the session gets created when a name is given and the <code>Add Session</code> button is clicked:</p>
<pre><code class="language-kt">// Tells the `Add Session` button on the screen
// to execute this code when it is clicked
binding.btnAddSession.setOnClickListener {
    // Gets the name from the text field in the screen
    val text = binding.etSession.text.toString()

    // Does not do anything if there is no name associated
    // with the session
    if (text.isEmpty()) {
        return@setOnClickListener
    }

    // Adds the session to the database
    val id = db.addSession(text, 2, 3)

    // Clears the text field
    binding.etSession.text.clear()

    // Creates an instance of the session model
    val session = Session(id, text, 2, 3)

    // Creates a button in the Sessions screen
    // with the data from the instance
    addButton(session)
}
</code></pre>
<p>And the model is used when a button for the session is created:</p>
<pre><code class="language-kt">private fun addButton(session: Session) {
    // A button is created
    val btn = Button(requireContext())
    // The label of the button is retrieved from
    // the name of the session
    btn.text = session.name
    // Tells the created button to
    // execute the code inside when it is clicked
    btn.setOnClickListener {
        prefs.setSession(session.id)
        binding.tvSession.text = session.name
    }

    // Tells the created button to
    // execute the code inside when it is held
    btn.setOnLongClickListener {
        // The records of the session is deleted from the database
        db.deleteSession(session.id)
        // The button is removed from the UI
        binding.llSessions.removeView(it)
        // The session saved in the preferences is reset
        if (session.id == prefs.getSession()) {
            prefs.setSession(0L)
        }
        // The UI is changed in order to indicate
        // the removal of the session
        binding.tvSession.text = &quot;No Session Selected&quot;
        return@setOnLongClickListener true
    }

    binding.llSessions.addView(btn)
}
</code></pre>
<p>In order to understand models, we only need to focus on the following lines of code:</p>
<pre><code class="language-kt">// binding.btnAddSession.setOnClickListener {
    val text = binding.etSession.text.toString()
    // if (text.isEmpty()) {
    //     return@setOnClickListener
    // }

    val id = db.addSession(text, 2, 3)
    // binding.etSession.text.clear()
    val session = Session(id, text, 2, 3)
    addButton(session)
}
</code></pre>
<p>When an instance of a <code>Session</code> is created in <code>val session = Session(id, text, 2, 3)</code>,
it calls upon the constructor of the <code>Session</code> class and sets the appropriate value:</p>
<pre><code class="language-kt">class Session(
	val id: Long,     // id
	var name: String, // text
	var rows: Int,    // 2
	var cols: Int     // 3
)
</code></pre>
<p>So the <code>name</code> comes from the text set in the input field in the application,
the <code>id</code> is retrieved from adding a record of the session to the database with the <a href="chapters/models/dbhelper.html"><code>DBHelper</code></a> class,
and the <code>rows</code> and <code>cols</code> are set to <code>2</code> and <code>3</code> respectively by default.
After creating an instance of the session with this data,
it is then used when a button is added to the screen.</p>
<p>From the instance of the session passed through the <code>addButton</code> function,
the <code>name</code> is used in order to label the button and the session indicator,
the <code>id</code> is used to save the session to the preferences and
delete its entry from the database,
while the <code>rows</code> and <code>cols</code> are used elsewhere.</p>
<pre><code class="language-kt">private fun addButton(session: Session) {
    // val btn = Button(requireContext())
    btn.text = session.name
    btn.setOnClickListener {
        prefs.setSession(session.id)
        binding.tvSession.text = session.name
    }
    btn.setOnLongClickListener {
        db.deleteSession(session.id)
        // binding.llSessions.removeView(it)
        if (session.id == prefs.getSession()) {
            prefs.setSession(0L)
        }
        // binding.tvSession.text = &quot;No Session Selected&quot;
        // return@setOnLongClickListener true
    }

    // binding.llSessions.addView(btn)
}
</code></pre>
<p>In conclusion, by using models,
the program is able to containerize the data it receives from different sources
and use these data from a single source.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rowdata"><a class="header" href="#rowdata">RowData</a></h1>
<p>The <code>RowData</code> class is used for saving and restoring the RSSI values recorded.</p>
<h2 id="snippet-4"><a class="header" href="#snippet-4">Snippet</a></h2>
<pre><code class="language-kt">class RowData (
	val recordId: Long,
	val label: Int
) {
	val values = arrayListOf&lt;Float&gt;()

	fun addVal(value: Float) {
		values.add(value)
	}

	override fun toString(): String {
		return &quot;$recordId: $label; $values&quot;
	}
}
</code></pre>
<h2 id="fields-1"><a class="header" href="#fields-1">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>recordID</td><td><code>val recordID: Long</code></td><td>Used to identify the record in the database.</td></tr>
<tr><td>label</td><td><code>val label: Int</code></td><td>The number of cars occupied for the set of RSSI values recorded.</td></tr>
<tr><td>values</td><td><code>val values = arrayListOf&lt;Float&gt;</code></td><td>The RSSI values for this row.</td></tr>
</tbody></table>
</div>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<h3 id="addval"><a class="header" href="#addval">addVal</a></h3>
<p>The <code>addVal</code> method adds the RSSI value from a router to <code>values</code>.</p>
<h4 id="snippet-5"><a class="header" href="#snippet-5">Snippet</a></h4>
<pre><code class="language-kt">fun addVal(value: Float){
	values.add(value)
}
</code></pre>
<h4 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>value</td><td><code>value: Float</code></td><td>The RSSI value received from a router.</td></tr>
</tbody></table>
</div>
<h2 id="overrides"><a class="header" href="#overrides">Overrides</a></h2>
<h3 id="tostring"><a class="header" href="#tostring">toString</a></h3>
<p>Overrides the default toString method to the string format.</p>
<h4 id="snippet-6"><a class="header" href="#snippet-6">Snippet</a></h4>
<pre><code class="language-kt">override fun toString(): String{
	return &quot;$recordID: $label; $values&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session"><a class="header" href="#session">Session</a></h1>
<p>The <code>Session</code> class contains information for saving and restoring sessions
which are configurations for the routers.</p>
<h2 id="snippet-7"><a class="header" href="#snippet-7">Snippet</a></h2>
<pre><code class="language-kt">class Session(
	val id: Long,
	var name: String,
	var rows: Int,
	var cols: Int
) {
	override fun toString(): String {
		return &quot;Id: $id; Name: $name; Rows: $rows; Cols: $cols\n&quot;
	}
}
</code></pre>
<h2 id="fields-2"><a class="header" href="#fields-2">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td>Used to identify the record in the database</td></tr>
<tr><td>name</td><td>The name set by the user to identify the session</td></tr>
<tr><td>rows</td><td>The number of rows for the router matrix</td></tr>
<tr><td>cols</td><td>The number of columns for the router matrix</td></tr>
</tbody></table>
</div>
<h2 id="overrides-1"><a class="header" href="#overrides-1">Overrides</a></h2>
<h3 id="tostring-1"><a class="header" href="#tostring-1">toString</a></h3>
<p>Overrides the default toString method to the string format.</p>
<h4 id="snippet-8"><a class="header" href="#snippet-8">Snippet</a></h4>
<pre><code class="language-kt">override fun toString(): String{
	return &quot;Id: $id; Name: $name; Rows: $rows; Cols: $cols\n&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router"><a class="header" href="#router">Router</a></h1>
<p>The <code>Router</code> class contains the information for each router the app connects to.
It is located at <code>app &gt; java &gt; com.silentrald.parkingrssi &gt; Router.kt</code>.</p>
<h2 id="fields-3"><a class="header" href="#fields-3">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>bssid</td><td><code>private var bssid: Long = 0L</code></td><td>The network address received from the <a href="https://developer.android.com/guide/topics/connectivity/wifi-scan">wifi manager</a></td></tr>
<tr><td>bssidStr</td><td><code>private var bssidStr: String</code></td><td>The network address received from the <a href="https://developer.android.com/guide/topics/connectivity/wifi-scan">wifi manager</a></td></tr>
<tr><td>name</td><td><code>private var name: String</code></td><td>The name of the network.</td></tr>
<tr><td>row</td><td><code>var row: Int = 0</code></td><td>Which row in the router matrix the router is set</td></tr>
<tr><td>col</td><td><code>var col: Int = 0</code></td><td>Which column in the router matrix the router is set</td></tr>
</tbody></table>
</div>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<h3 id="routerlong-string"><a class="header" href="#routerlong-string">Router(Long, String)</a></h3>
<p>Creates a router using a <code>Long</code> and <code>String</code> parameters.</p>
<h4 id="snippet-9"><a class="header" href="#snippet-9">Snippet</a></h4>
<pre><code class="language-kt">constructor(bssid: Long, name: String) {
    this.bssid = bssid
    this.name = name

    this.bssidStr = convertBSSIDToString(bssid)
}
</code></pre>
<h3 id="routerstring-string"><a class="header" href="#routerstring-string">Router(String, String)</a></h3>
<p>Creates a router using a <code>String</code> and <code>String</code> parameters.</p>
<h4 id="snippet-10"><a class="header" href="#snippet-10">Snippet</a></h4>
<pre><code class="language-kt">constructor(bssidStr: String, name: String) {
    this.bssidStr = bssidStr
    this.name = name

    this.bssid = convertBSSIDToLong(bssidStr)
}
</code></pre>
<h2 id="methods-2"><a class="header" href="#methods-2">Methods</a></h2>
<h3 id="getbssid"><a class="header" href="#getbssid">getBSSID</a></h3>
<p>Returns the <code>bssid</code> of the router.</p>
<h4 id="snippet-11"><a class="header" href="#snippet-11">Snippet</a></h4>
<pre><code class="language-kt">fun getBSSID(): Long{
    return this.bssid
}
</code></pre>
<h3 id="getbssidstr"><a class="header" href="#getbssidstr">getBSSIDStr</a></h3>
<p>Returns the <code>bssidStr</code> of the router.</p>
<h4 id="snippet-12"><a class="header" href="#snippet-12">Snippet</a></h4>
<pre><code class="language-kt">fun getBSSIDStr(): String{
    return this.bssidStr
}
</code></pre>
<h3 id="getname"><a class="header" href="#getname">getName</a></h3>
<p>Returns the <code>name</code> of the router.</p>
<h4 id="snippet-13"><a class="header" href="#snippet-13">Snippet</a></h4>
<pre><code class="language-kt">fun getName(): String{
    return this.name
}
</code></pre>
<h3 id="convertbssidtolong"><a class="header" href="#convertbssidtolong">convertBSSIDToLong</a></h3>
<p>Formats the <code>bssidStr</code> to a <code>Long</code> type.</p>
<h4 id="snippet-14"><a class="header" href="#snippet-14">Snippet</a></h4>
<pre><code class="language-kt">private fun convertBSSIDToLong(bssidStr: String): Long {
    val str = bssidStr.replace(&quot;:&quot;, &quot;&quot;)

    return str.toLong(16)
}
</code></pre>
<h3 id="convertbssidtostring"><a class="header" href="#convertbssidtostring">convertBSSIDToString</a></h3>
<p>Formats the <code>bssid</code> to a <code>String</code> type.</p>
<h4 id="snippet-15"><a class="header" href="#snippet-15">Snippet</a></h4>
<pre><code class="language-kt">private fun convertBSSIDToString(bssid: Long): String {
    var bssidStr = bssid.toString(16)

    bssidStr = &quot;${
      bssidStr.substring(0, 2)
    }:${
      bssidStr.substring(2, 4)
    }:${
      bssidStr.substring(4, 6)
    }:${
      bssidStr.substring(6, 8)
    }:${
      bssidStr.substring(8, 10)
    }:${
      bssidStr.substring(10)
    }&quot;

    return bssidStr
}
</code></pre>
<h2 id="overrides-2"><a class="header" href="#overrides-2">Overrides</a></h2>
<h3 id="tostring-2"><a class="header" href="#tostring-2">toString</a></h3>
<p>Overrides the default toString method to the string format.</p>
<h4 id="snippet-16"><a class="header" href="#snippet-16">Snippet</a></h4>
<pre><code class="language-kt">override fun toString(): String{
    return &quot;$bssid: $name&lt;$bssidStr&gt; ($row, $col)&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="singletons"><a class="header" href="#singletons">Singletons</a></h1>
<p>Singletons are classes which only has a single instance during the runtime of the application.
When a class is used by the program, it is often instantiated with a constructor like so:</p>
<pre><code class="language-kt">val session = Session(0, &quot;Session 1&quot;, 2, 3);
</code></pre>
<p>This creates an instance of a session with the following data:</p>
<div class="table-wrapper"><table><thead><tr><th>variable</th><th>id</th><th>name</th><th>rows</th><th>cols</th></tr></thead><tbody>
<tr><td>session</td><td>0</td><td>Session 1</td><td>2</td><td>3</td></tr>
</tbody></table>
</div>
<p>This means that every time we use the variable <code>session</code>,
we would always get the following data
(unless it has been changed, but for this example let us assume that it doesn't).</p>
<p>This means that if we wish to use create another session, we would create another instance like so:</p>
<pre><code class="language-kt">val session2 = Session(1, &quot;Session 2&quot;, 4, 4)
</code></pre>
<p>Which would create an instance of a session with the following data:</p>
<div class="table-wrapper"><table><thead><tr><th>variable</th><th>id</th><th>name</th><th>rows</th><th>cols</th></tr></thead><tbody>
<tr><td>session2</td><td>1</td><td>Session 2</td><td>4</td><td>4</td></tr>
</tbody></table>
</div>
<p>So if we are to print out <code>session.id</code> and <code>session2.id</code> we would have <code>0</code> and <code>1</code> as our results respectively.</p>
<p>However, there are times where we only need a single instance of a class
and having multiple instances of these classes would be disastrous as it can lead to inaccurate data.
In this application, the <a href="chapters/models/dbhelper.html"><code>DBHelper</code></a> and <a href="chapters/models/prefs.html"><code>Prefs</code></a> classes are singletons because
we do not want our records and settings be saved to different instances which can cause sync issues.</p>
<p>It is important to know that instances are not limited to separate variables.
Since variables are only containers,its contents can be easily replaced.
For example, we created an instance of <code>DBHelper</code> and stored it in the <code>dbHelper</code> variable.
Somewhere along the line, <code>DBHelper</code> has been instantiated and kept in the <code>dbHelper</code> variable.
This would mean that <code>dbHelper</code> would no longer be able to access all of the data recorded in it before.</p>
<p>Singletons help prevent this issue because they ensure that only a single instance of the class lives.</p>
<p>An implementation of a Singleton can be seen like so:</p>
<pre><code class="language-kt">// A container for the singleton instance
private var sInstance: DBHelper? = null
@Synchronized
fun getInstance(ctx: Context): DBHelper? {
    // Checks if there is an existing instance
    if (sInstance == null) {
        // if there is none, an instance is created
        sInstance = DBHelper(ctx.applicationContext)
    }
    // Returns the instance to whatever needs it
    return sInstance
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefs"><a class="header" href="#prefs">Prefs</a></h1>
<p>The <code>Prefs</code> class is responsible for the default preferences between sessions.</p>
<h2 id="snippet-17"><a class="header" href="#snippet-17">Snippet</a></h2>
<pre><code class="language-kt">class Prefs(context: Context) {
  private val PREFS = &quot;parkingrssi&quot;

  private val CAPACITY_KEY = &quot;capacity&quot;
  private val SESSION_KEY = &quot;session&quot;

  private val CAPACITY_DEFAULT = 10
  private val SESSION_NULL = 0L

  private var sp: SharedPreferences

  init {
    sp = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
  }

  fun setCapacity(value: Int) {
    sp.edit().putInt(CAPACITY_KEY, value).apply()
  }

  fun setSession(value: Long) {
    sp.edit().putLong(SESSION_KEY, value).apply()
  }

  fun getCapacity(): Int {
    return sp.getInt(CAPACITY_KEY, CAPACITY_DEFAULT)
  }

  fun getSession(): Long {
    return sp.getLong(SESSION_KEY, SESSION_NULL)
  }

  companion object {
    // Singleton
    private var sInstance: Prefs? = null
    @Synchronized
    fun getInstance(ctx: Context): Prefs? {
      if (sInstance == null) {
        sInstance = Prefs(ctx)
      }
      return sInstance
    }
  }
}
</code></pre>
<h2 id="fields-4"><a class="header" href="#fields-4">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Fields</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>PREFS</td><td><code>private val PREFS = &quot;parkingrssi&quot;</code></td><td>Used to identify the preferences saved on the device</td></tr>
<tr><td>CAPACITY_KEY</td><td><code>private val CAPACITY_KEY = &quot;capacity&quot;</code></td><td>Used to identify the saved capacity on the device</td></tr>
<tr><td>SESSION_KEY</td><td><code>private val SESSION_KEY = &quot;session&quot;</code></td><td>Used to identify the saved session on the device</td></tr>
<tr><td>CAPACITY_DEFAULT</td><td><code>private val CAPACITY_DEFAULT = 10</code></td><td>The default capacity saved to the device if no capacity has been set</td></tr>
<tr><td>SESSION_NULL</td><td><code>private val SESSION_NULL = 0L</code></td><td>The default session saved to the device if no session has been set</td></tr>
<tr><td>sp</td><td><code>private var sp: SharedPreferences</code></td><td><a href="https://developer.android.com/reference/android/content/SharedPreferences">SharedPreferences</a> which are used to access data from the device.</td></tr>
</tbody></table>
</div>
<h2 id="methods-3"><a class="header" href="#methods-3">Methods</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td>setCapacity (value: Int)</td><td>Sets the capacity saved in the <code>SharedPreferences</code> to the value passed through.</td></tr>
<tr><td>setSession (value: Long)</td><td>Sets the session saved in the <code>SharedPreferences</code> to the value passed through.</td></tr>
<tr><td>getCapacity</td><td>Gets the capacity saved in the <code>SharedPreferences</code>.</td></tr>
<tr><td>getSession</td><td>Gets the session saved in the <code>SharedPreferences</code>.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dbhelper"><a class="header" href="#dbhelper">DBHelper</a></h1>
<p>The <code>DBHelper</code> class is responsible for <a href="https://developer.android.com/training/data-storage/sqlite">saving data in an SQLite database</a>.
The data is stored in an SQLite database so that it is easily accessible and scalable given the amount of data that is used by the application.
The <code>DBHelper</code> class contains methods responsible for setting up the SQLite database, the different tables within it, and how to add and remove data to those tables.</p>
<h2 id="snippet-18"><a class="header" href="#snippet-18">Snippet</a></h2>
<pre><code class="language-kt">class DBHelper(context: Context) :
  SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {
  private val TAG = &quot;DB&quot;

  override fun onCreate(db: SQLiteDatabase) {
    db.execSQL(&quot;&quot;&quot;
      CREATE TABLE $SESSION_TABLE (
        $SESSION_ID     INTEGER      PRIMARY KEY AUTOINCREMENT,
        $SESSION_NAME   VARCHAR(100) NOT NULL,
        $SESSION_ROWS   INTEGER      NOT NULL,
        $SESSION_COLS   INTEGER      NOT NULL
      );
    &quot;&quot;&quot;.trimIndent())

    db.execSQL(&quot;&quot;&quot;
      CREATE TABLE $ROUTER_TABLE (
        $ROUTER_BSSID   INTEGER     PRIMARY KEY,
        $ROUTER_NAME  VARCHAR(100)  NOT NULL
      );
    &quot;&quot;&quot;.trimIndent())

    db.execSQL(&quot;&quot;&quot;
      CREATE TABLE $SESSION_ROUTER_TABLE (
        $SESSION_ROUTER_ID          INTEGER PRIMARY KEY AUTOINCREMENT,
        $SESSION_ROUTER_SESSION_ID  INTEGER NOT NULL,
        $SESSION_ROUTER_ROUTER_ID   INTEGER NOT NULL,
        $SESSION_ROUTER_ROW         INTEGER NOT NULL,
        $SESSION_ROUTER_COL         INTEGER NOT NULL,
        FOREIGN KEY($SESSION_ROUTER_SESSION_ID) REFERENCES $SESSION_TABLE($SESSION_ID) ON DELETE CASCADE,
        FOREIGN KEY($SESSION_ROUTER_ROUTER_ID) REFERENCES $ROUTER_TABLE($ROUTER_BSSID),
        UNIQUE($SESSION_ROUTER_SESSION_ID, $SESSION_ROUTER_ROUTER_ID)
      );
    &quot;&quot;&quot;.trimIndent())

    db.execSQL(&quot;&quot;&quot;
      CREATE TABLE $RECORD_TABLE (
        $RECORD_ID          INTEGER   PRIMARY KEY AUTOINCREMENT,
        $RECORD_SESSION_ID  INTEGER   NOT NULL,
        $RECORD_LABEL       INTEGER   NOT NULL,
        $RECORD_TIMESTAMP   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY($RECORD_SESSION_ID) REFERENCES $SESSION_TABLE($SESSION_ID) ON DELETE CASCADE
      );
    &quot;&quot;&quot;.trimIndent())

    db.execSQL(&quot;&quot;&quot;
      CREATE TABLE $DATA_TABLE (
        $DATA_ID          INTEGER PRIMARY KEY AUTOINCREMENT,
        $DATA_RECORD_ID   INTEGER NOT NULL,
        $DATA_ROUTER_ID   INTEGER NOT NULL,
        $DATA_VALUE       INTEGER NOT NULL,
        FOREIGN KEY($DATA_RECORD_ID) REFERENCES $RECORD_ID($RECORD_ID) ON DELETE CASCADE,
        FOREIGN KEY($DATA_ROUTER_ID) REFERENCES $ROUTER_TABLE($ROUTER_BSSID)
      )
    &quot;&quot;&quot;.trimIndent())
  }

  override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
    if (db == null) return;
    db.execSQL(&quot;DROP TABLE IF EXISTS $DATA_TABLE&quot;)
    db.execSQL(&quot;DROP TABLE IF EXISTS $RECORD_TABLE&quot;)
    db.execSQL(&quot;DROP TABLE IF EXISTS $SESSION_ROUTER_TABLE&quot;)
    db.execSQL(&quot;DROP TABLE IF EXISTS $ROUTER_TABLE&quot;)
    db.execSQL(&quot;DROP TABLE IF EXISTS $SESSION_TABLE&quot;)
    onCreate(db)
  }

  // Session
  fun addSession(name: String, rows: Int, cols: Int): Long {
    val values = ContentValues()
    values.put(SESSION_NAME, name)
    values.put(SESSION_ROWS, rows)
    values.put(SESSION_COLS, cols)

    val db = this.writableDatabase
    return try {
      db.insertOrThrow(SESSION_TABLE, null, values)
    } catch (e: Exception) {
      Log.e(TAG, Log.getStackTraceString(e))
      -1L
    }
  }

  fun updateSession(session: Session) {
    val values = ContentValues()
    values.put(SESSION_NAME, session.name)
    values.put(SESSION_ROWS, session.rows)
    values.put(SESSION_COLS, session.cols)

    val db = this.writableDatabase
    db.update(SESSION_TABLE, values,
      &quot;$SESSION_ID=?&quot;, arrayOf(session.id.toString()))
  }

  fun getSessionById(id: Long): Session? {
    val db = this.readableDatabase
    val query = &quot;&quot;&quot;
      SELECT  *
      FROM    $SESSION_TABLE
      WHERE   $SESSION_ID=?
      LIMIT   1;
    &quot;&quot;&quot;.trimIndent()
    val cursor = db.rawQuery(query, arrayOf(id.toString()))
    if (!cursor.moveToFirst()) {
      return null
    }

    return Session(
      cursor.getLong(cursor.getColumnIndex(SESSION_ID)),
      cursor.getString(cursor.getColumnIndex(SESSION_NAME)),
      cursor.getInt(cursor.getColumnIndex(SESSION_ROWS)),
      cursor.getInt(cursor.getColumnIndex(SESSION_COLS))
    )
  }
  
  @SuppressLint(&quot;Recycle&quot;)
  fun getAllSessions(): ArrayList&lt;Session&gt; {
    val db = this.readableDatabase
    val query = &quot;&quot;&quot;
      SELECT  *
      FROM    $SESSION_TABLE;
    &quot;&quot;&quot;.trimIndent()
    val cursor = db.rawQuery(query, null)
    if (!cursor.moveToFirst()) {
      return arrayListOf()
    }

    val idIndex = cursor.getColumnIndex(&quot;id&quot;)
    val nameIndex = cursor.getColumnIndex(&quot;name&quot;)
    val rowsIndex = cursor.getColumnIndex(&quot;rows&quot;)
    val colsIndex = cursor.getColumnIndex(&quot;cols&quot;)
    val sessions = arrayListOf&lt;Session&gt;()
    do {
      sessions.add(Session(
        cursor.getLong(idIndex),
        cursor.getString(nameIndex),
        cursor.getInt(rowsIndex),
        cursor.getInt(colsIndex)
      ))
    } while (cursor.moveToNext())

    return sessions
  }

  fun deleteSession(id: Long) {
    val db = this.writableDatabase
    db.delete(SESSION_TABLE, &quot;id=?&quot;, arrayOf(id.toString()))
  }

  // Router Db CRUD
  fun addRouter(bssid: Long, name: String) {
    val values = ContentValues()
    values.put(ROUTER_BSSID, bssid)
    values.put(ROUTER_NAME, name)

    val db = this.writableDatabase
    db.insertWithOnConflict(
      ROUTER_TABLE, null,
      values, SQLiteDatabase.CONFLICT_IGNORE
    )
  }

  /**
   * Gets all the routers added
   *
   * @return Map of (bssid: router name)
   */
  @SuppressLint(&quot;Recycle&quot;)
  fun getRouters(): ArrayList&lt;Router&gt; {
    val db = this.readableDatabase
    val query = &quot;&quot;&quot;
      SELECT  *
      FROM  $ROUTER_TABLE;
    &quot;&quot;&quot;.trimIndent()
    val cursor = db.rawQuery(query, null)
    if (!cursor!!.moveToFirst()) {
      return arrayListOf()
    }

    val routers = arrayListOf&lt;Router&gt;()
    do {
      routers.add(Router(
        cursor.getLong(cursor.getColumnIndex(ROUTER_BSSID)),
        cursor.getString(cursor.getColumnIndex(ROUTER_NAME))
      ))
    } while (cursor.moveToNext())

    return routers
  }

  // Session Router Db CRUD
  /**
   * Adds a new session router row
   *
   * @param sessionId Session Id
   * @param bssid Router Id
   * @param row Row of the router in the matrix
   * @param col Col of the router in the matrix
   */
  fun addSessionRouter(sessionId: Long, bssid: Long, row: Int, col: Int) {
    val values = ContentValues()
    values.put(SESSION_ROUTER_SESSION_ID, sessionId)
    values.put(SESSION_ROUTER_ROUTER_ID, bssid)
    values.put(SESSION_ROUTER_ROW, row)
    values.put(SESSION_ROUTER_COL, col)

    val db = this.writableDatabase
    db.insert(SESSION_ROUTER_TABLE, null, values)
  }

  fun deleteSessionRouters(sessionId: Long) {
    val db = this.writableDatabase
    db.delete(SESSION_ROUTER_TABLE, &quot;$SESSION_ROUTER_SESSION_ID=?&quot;, arrayOf(sessionId.toString()))
  }

  /**
   *
   */
  @SuppressLint(&quot;Recycle&quot;)
  fun getSessionRouters(sessionId: Long): ArrayList&lt;Router&gt; {
    val db = this.readableDatabase
    val query = &quot;&quot;&quot;
      SELECT
        r.$ROUTER_BSSID AS id,
        r.$ROUTER_NAME AS name,
        sr.$SESSION_ROUTER_ROW AS `row`,
        sr.$SESSION_ROUTER_COL AS col
      FROM (
        SELECT    *
        FROM      $SESSION_ROUTER_TABLE
        WHERE     $SESSION_ROUTER_SESSION_ID=?
      ) AS sr
      JOIN        $ROUTER_TABLE r
        ON        r.$ROUTER_BSSID = sr.$SESSION_ROUTER_ROUTER_ID
      ORDER BY    sr.$SESSION_ROUTER_ROW, sr.$SESSION_ROUTER_COL;
    &quot;&quot;&quot;.trimIndent()
    val cursor = db.rawQuery(query, arrayOf(sessionId.toString()))
    if (!cursor!!.moveToFirst()) {
      return arrayListOf()
    }

    val bssidIndex = cursor.getColumnIndex(&quot;id&quot;)
    val nameIndex = cursor.getColumnIndex(&quot;name&quot;)
    val rowIndex = cursor.getColumnIndex(&quot;row&quot;)
    val colIndex = cursor.getColumnIndex(&quot;col&quot;)

    val routers = arrayListOf&lt;Router&gt;()
    do {
      val router = Router(
        cursor.getLong(bssidIndex),
        cursor.getString(nameIndex)
      )
      router.row = cursor.getInt(rowIndex)
      router.col = cursor.getInt(colIndex)
      routers.add(router)
    } while (cursor.moveToNext())

    return routers
  }

  // Record and Data
  /**
   * Adds a row of data to a session
   *
   * @param label
   * @param values Key Value pair of router bssid and value
   */
  fun addRow(sessionId: Long, label: Int, values: HashMap&lt;Long, Float&gt;) {
    val db = this.writableDatabase
    db.transaction {
      // Create a record
      val contentValues = ContentValues()
      contentValues.put(RECORD_SESSION_ID, sessionId)
      contentValues.put(RECORD_LABEL, label)

      val id: Long = this.insert(RECORD_TABLE, null, contentValues)

      for ((bssid, value) in values) {
        Log.d(TAG, &quot;INSERTING: $bssid: $value&quot;)
        contentValues.clear()
        contentValues.put(DATA_RECORD_ID, id)
        contentValues.put(DATA_ROUTER_ID, bssid)
        contentValues.put(DATA_VALUE, value)
        this.insert(DATA_TABLE, null, contentValues)
      }
    }
  }

  /**
   * Updates a row of data
   *
   * @param sessionId To get the current routers
   * @param recordId Record id
   * @param values Array of new dbm values
   */
  fun updateRow(sessionId: Long, recordId: Long, values: ArrayList&lt;Float&gt;): Boolean {
    // Get the ordered session routers
    val routers = getSessionRouters(sessionId)

    if (routers.size != values.size) {
      Log.e(TAG, &quot;Size not matching ${routers.size} ${values.size}&quot;)
      return false
    }

    val db = this.writableDatabase
    try {
      db.transaction {
        val contentValues = ContentValues()
        for (i in 0 until routers.size) {
          contentValues.clear()
          contentValues.put(DATA_VALUE, values[i])

          val wheres = arrayOf(recordId.toString(), routers[i].getBSSID().toString())
          this.update(DATA_TABLE, contentValues,
            &quot;$DATA_RECORD_ID=? AND $DATA_ROUTER_ID=?&quot;,
            wheres
          )
        }
      }
    } catch (e: Exception) {
      Log.e(TAG, Log.getStackTraceString(e))
      return false
    }

    return true
  }

  /**
   * Deletes a row of data
   *
   * @param recordId The record table
   */
  fun deleteRow(recordId: Long) {
    val db = this.writableDatabase
    db.delete(RECORD_TABLE, &quot;$RECORD_ID=?&quot;, arrayOf(recordId.toString()))
  }

  /**
   * Deletes all rows from a session
   *
   * @param sessionId
   */
  fun deleteSessionRows(sessionId: Long) {
    val db = this.writableDatabase
    db.delete(RECORD_TABLE, &quot;$RECORD_SESSION_ID=?&quot;, arrayOf(sessionId.toString()))
  }

  /**
   * Returns the whole data set of labels and values
   *
   * @param sessionId Session
   * @return
   */
  @SuppressLint(&quot;Recycle&quot;)
  fun getData(sessionId: Long): ArrayList&lt;RowData&gt; {
    val db = this.readableDatabase

    val session = getSessionById(sessionId) ?: return arrayListOf()
    val size = session.rows * session.cols

    // Get all rows
    val rowCursor = db.rawQuery(&quot;&quot;&quot;
      SELECT    $RECORD_ID, $RECORD_LABEL
      FROM      $RECORD_TABLE
      WHERE     $RECORD_SESSION_ID=?
      ORDER BY  $RECORD_TIMESTAMP;
    &quot;&quot;&quot;.trimIndent(), arrayOf(sessionId.toString()))

    if (!rowCursor.moveToFirst()) {
      Log.e(TAG, &quot;No rows found&quot;)
      rowCursor.close()
      return arrayListOf()
    }

    // Query per row
    val idIndex = rowCursor.getColumnIndex(RECORD_ID)
    val labelIndex = rowCursor.getColumnIndex(RECORD_LABEL)
    val data = arrayListOf&lt;RowData&gt;()
    do {
      val rowData = RowData(rowCursor.getLong(idIndex), rowCursor.getInt(labelIndex))

      val colCursor = db.rawQuery(&quot;&quot;&quot;
        SELECT  sr.$SESSION_ROUTER_ROUTER_ID, d.$DATA_VALUE
        FROM (
          SELECT  *
          FROM    $DATA_TABLE
          WHERE   $DATA_RECORD_ID=?
          LIMIT   ?
        ) AS d
        LEFT JOIN ( -- TODO: Can be placed in a temporary table
          SELECT  *
          FROM    $SESSION_ROUTER_TABLE
          WHERE   $SESSION_ROUTER_SESSION_ID=?
          LIMIT   ?
        ) AS sr
          ON        sr.$SESSION_ROUTER_ROUTER_ID = d.$DATA_ROUTER_ID
        ORDER BY    sr.$SESSION_ROUTER_ROW, sr.$SESSION_ROUTER_COL;
      &quot;&quot;&quot;.trimIndent(), arrayOf(
        rowCursor.getString(idIndex), size.toString(),
        sessionId.toString(), size.toString()
      ))

      if (!colCursor.moveToFirst()) {
        Log.e(TAG, &quot;No cols were found&quot;)
        colCursor.close()
        rowCursor.close()
        return arrayListOf() // ERROR
      }

      val valIndex = colCursor.getColumnIndex(DATA_VALUE)
      do {
        rowData.addVal(colCursor.getFloat(valIndex))
      } while (colCursor.moveToNext())
      colCursor.close()

      if (rowData.values.size != size) {
        Log.e(TAG, &quot;Size does not match, ${rowData.values.size} != $size&quot;)
        rowCursor.close()
        return arrayListOf() // ERROR
      }

      data.add(rowData)
    } while (rowCursor.moveToNext())
    rowCursor.close()

    return data
  }

  companion object {
    // Singleton
    private var sInstance: DBHelper? = null
    @Synchronized
    fun getInstance(ctx: Context): DBHelper? {
      if (sInstance == null) {
        sInstance = DBHelper(ctx.applicationContext)
      }
      return sInstance
    }

    private const val DATABASE_NAME = &quot;parking_rssi&quot;
    private const val DATABASE_VERSION = 13

    // SESSIONS
    const val SESSION_TABLE = &quot;sessions&quot;
    const val SESSION_ID = &quot;id&quot;
    const val SESSION_NAME = &quot;name&quot;
    const val SESSION_ROWS = &quot;rows&quot;
    const val SESSION_COLS = &quot;cols&quot;

    // ROUTERS
    const val ROUTER_TABLE = &quot;routers&quot;
    const val ROUTER_BSSID = &quot;bssid&quot;
    const val ROUTER_NAME = &quot;name&quot;

    // SESSION_ROUTERS
    const val SESSION_ROUTER_TABLE = &quot;session_routers&quot;
    const val SESSION_ROUTER_ID = &quot;id&quot;
    const val SESSION_ROUTER_SESSION_ID = &quot;session_id&quot;
    const val SESSION_ROUTER_ROUTER_ID = &quot;router_id&quot;
    const val SESSION_ROUTER_ROW = &quot;r&quot;
    const val SESSION_ROUTER_COL = &quot;c&quot;

    // RECORDS
    const val RECORD_TABLE = &quot;records&quot;
    const val RECORD_ID = &quot;id&quot;
    const val RECORD_SESSION_ID = &quot;session_id&quot;
    const val RECORD_LABEL = &quot;label&quot;
    const val RECORD_TIMESTAMP = &quot;timestamp&quot;

    // DATA
    const val DATA_TABLE = &quot;data&quot;
    const val DATA_ID = &quot;id&quot;
    const val DATA_RECORD_ID = &quot;record_id&quot;
    const val DATA_ROUTER_ID = &quot;router_id&quot;
    const val DATA_VALUE = &quot;value&quot;
  }
}

</code></pre>
<h2 id="tables"><a class="header" href="#tables">Tables</a></h2>
<blockquote>
<p><strong>NOTE:</strong> The values for each table provided is only for visualization.</p>
</blockquote>
<h3 id="session-table"><a class="header" href="#session-table">Session Table</a></h3>
<p>The session table records the name, rows, and columns of a specific session.</p>
<div class="table-wrapper"><table><thead><tr><th>id</th><th>name</th><th>rows</th><th>cols</th></tr></thead><tbody>
<tr><td>0</td><td>Session 1</td><td>3</td><td>2</td></tr>
</tbody></table>
</div>
<h3 id="router-table"><a class="header" href="#router-table">Router Table</a></h3>
<p>The router table records the BSSID or the MAC address of a router as well as its name.</p>
<div class="table-wrapper"><table><thead><tr><th>bssid</th><th>name</th></tr></thead><tbody>
<tr><td>208914460048774</td><td>66852627208993-xiaomi-repeater-v3_miapdb21</td></tr>
</tbody></table>
</div>
<h3 id="session-router-table"><a class="header" href="#session-router-table">Session Router Table</a></h3>
<p>The session router table records a router in a given session, along with its positioning in the router matrix.</p>
<div class="table-wrapper"><table><thead><tr><th>id</th><th>session_id</th><th>router_id</th><th>r</th><th>c</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>208914460048774</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<h3 id="record-table"><a class="header" href="#record-table">Record Table</a></h3>
<p>The record table records the total amount of cars (label) for a specific session as well as a timestamp to when it has been recorded.</p>
<div class="table-wrapper"><table><thead><tr><th>id</th><th>session_id</th><th>label</th><th>timestamp</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>5</td><td>1667021128</td></tr>
</tbody></table>
</div>
<h3 id="data-table"><a class="header" href="#data-table">Data Table</a></h3>
<p>The data table links the router, and the RSSI value associated with it to a record.</p>
<div class="table-wrapper"><table><thead><tr><th>id</th><th>record_id</th><th>router_id</th><th>value</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>208914460048774</td><td>[(208914460048774,-27.0)]</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="views"><a class="header" href="#views">Views</a></h1>
<p>The views are the actual elements that we interact with in the app.
This means that views are where the classes are instantiated, methods are called, etc.</p>
<p>The project has two main &quot;views&quot;, <code>Activities</code> and <code>Fragments</code>.
Activities are the user interface components of Android Studio and
usually used to create a single screen.
Fragments are used in order to be able to display multiple &quot;screens&quot;
on a single activity.</p>
<p>Looking at the <code>activity_main.xml</code>, there are two major components;
the <code>nav_view</code> and the <code>nav_host_fragment_activity_main</code> which is where
the fragments of the screens are located.</p>
<p><img src="https://i.imgur.com/Mdu9dlC.png" alt="" /></p>
<p>The <code>nav_view</code> is where the buttons to load the different fragments to display on the <code>nav_host_fragment_activity_main</code>.</p>
<h2 id="oncreateview-and-ondestroyview"><a class="header" href="#oncreateview-and-ondestroyview">onCreateView and onDestroyView</a></h2>
<p>The fragments override the <code>onCreateView</code> and <code>onDestroyView</code> methods.
This only means that code is executed whenever that fragment has been loaded or unloaded.</p>
<p>Let's take a look at <a href="chapters/views/sessionFragment.html"><code>SessionFragment</code></a> for example.</p>
<pre><code class="language-kt">override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
): View {
    // Connects the script to the elements in the xml file
    _binding = FragmentSessionBinding.inflate(inflater, container, false)
    val root: View = binding.root

    // Gets a reference to the prefs singleton
    prefs = Prefs.getInstance(requireContext())!!
    // Gets a reference to the dbHelper singleton
    db = DBHelper.getInstance(requireContext())!!

    // Sets up the session view
    setup()

    // Returns the root which is needed by the function
    return root
}
</code></pre>
<p>As we can see, on the <code>onCreateView</code>, everything the application will need gets loaded and setup.</p>
<pre><code class="language-kt">override fun onDestroyView() {
    super.onDestroyView()
    // Clears the connection of the script to the elements
    _binding = null
}
</code></pre>
<p>While on the <code>onDestroyView</code>, the connections of the script and elements gets unloaded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="main-activity"><a class="header" href="#main-activity">Main Activity</a></h1>
<p>The <code>MainActivity</code> class is where the main layout of the app is configured.
It is located at <code>app &gt; java &gt; com.silentrald.parkingrssi &gt; MainActivity.kt</code>.</p>
<p>The <code>MainActivity</code> class is automatically generated by Android Studio and it is used
in order to configure the navigation bar of the application.</p>
<p><img src="https://i.imgur.com/7bimawj.png" alt="" /></p>
<h2 id="snippet-19"><a class="header" href="#snippet-19">Snippet</a></h2>
<pre><code class="language-kt">class MainActivity : AppCompatActivity() {

  private lateinit var binding: ActivityMainBinding

  // Similar to the onCreateView of the fragments
  // Meaning that it gets loaded when the application is loaded
  override fun onCreate(savedInstanceState: Bundle?) {
    // Allows the default implementation of the function to run
    super.onCreate(savedInstanceState)

    // Connects the script to the xml file
    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)

    val navView: BottomNavigationView = binding.navView

    val navController = findNavController(R.id.nav_host_fragment_activity_main)
    // This is where the buttons to navigate to the different screens are configured
    val appBarConfiguration = AppBarConfiguration(
      setOf(
        R.id.navigation_home,
        R.id.navigation_scan_routers,
        R.id.navigation_session,
        R.id.navigation_data
      )
    )
    // Sets up the nav bar with the correct app configuration
    setupActionBarWithNavController(navController, appBarConfiguration)
    navView.setupWithNavController(navController)
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-fragment"><a class="header" href="#session-fragment">Session Fragment</a></h1>
<p>The session fragment is the screen where sessions can be added, selected, and deleted.
Sessions are used by the application to keep track of recordings and configurations with the database.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p><img src="https://i.imgur.com/4ZBU6jD.jpg" alt="" /></p>
<h2 id="snippet-20"><a class="header" href="#snippet-20">Snippet</a></h2>
<pre><code class="language-kt">class SessionFragment : Fragment() {
	private val TAG = &quot;SESSION&quot;

	private var _binding: FragmentSessionBinding? = null
	private val binding get() = _binding!!

	private lateinit var db: DBHelper
	private lateinit var prefs: Prefs

	override fun onCreateView(
		inflater: LayoutInflater,
		container: ViewGroup?,
		savedInstanceState: Bundle?
	): View {
		// Connects the script to the elements in the xml file
		_binding = FragmentSessionBinding.inflate(inflater, container, false)
		val root: View = binding.root

		// Gets a reference to the prefs singleton
		prefs = Prefs.getInstance(requireContext())!!
		// Gets a reference to the dbHelper singleton
		db = DBHelper.getInstance(requireContext())!!

		// Sets up the session view
		setup()

		// Returns the root which is needed by the function
		return root
	}

	private fun setup() {
		// Debugging Purpose
		db.printSessions()

		// Clears existing sessions in view
		binding.llSessions.removeAllViews()

		// Gets the session saved in the preferences
		val s = prefs.getSession()
		// Checks for each session from the database
		for (session in db.getAllSessions()) {
			// Adds a button for that session
			addButton(session)

			// Sets the label in the session view to the current session selected
			if (session.id == s) {
				binding.tvSession.text = session.name
			}
		}

		// Sets what happens when the add session button is pressed
		binding.btnAddSession.setOnClickListener {
			// Stores the text written in the session input field
			val text = binding.etSession.text.toString()
			// Checks if the text is empty
			// And does not continue
			if (text.isEmpty()) {
				return@setOnClickListener
			}

			// Adds a session to the database
			val id = db.addSession(text, 2, 3)
			// Clears the text in the input field
			binding.etSession.text.clear()
			// Creates an instance of a session
			val session = Session(id, text, 2, 3)
			// Creates the button for the session
			addButton(session)
		}
	}

	@SuppressLint(&quot;SetTextI18n&quot;)
	private fun addButton(session: Session) {
		// Creates a new button instance
		val btn = Button(requireContext())
		// Sets the name to the session
		btn.text = session.name
		// Sets what happens when the button is clicked
		btn.setOnClickListener {
			// Saves the session to the preferences
			prefs.setSession(session.id)
			// Sets the label in the session view to the session selected.
			binding.tvSession.text = session.name
		}

  		// Sets what happens when the button is held
		btn.setOnLongClickListener {
			// Delets the session from the database
			db.deleteSession(session.id)
			// Removes the session button from the view
			binding.llSessions.removeView(it)
			if (session.id == prefs.getSession()) {
				// Sets the session saved in the preferences
				// to the default
				prefs.setSession(0L)
			}

			// Sets the label in the session view to the text
			binding.tvSession.text = &quot;No Session Selected&quot;
			return@setOnLongClickListener true
		}

		// Adds the new button to the view
		binding.llSessions.addView(btn)
	}

	override fun onDestroyView() {
		super.onDestroyView()
    	// Clears the connection of the script to the elements
		_binding = null
	}
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scan-router-fragment"><a class="header" href="#scan-router-fragment">Scan Router Fragment</a></h1>
<p>The scan router fragment is the screen where routers are scanned, configured, and saved to the database.</p>
<h2 id="layout-1"><a class="header" href="#layout-1">Layout</a></h2>
<p><img src="https://i.imgur.com/AgiU6tC.jpg" alt="" /></p>
<h2 id="snippet-21"><a class="header" href="#snippet-21">Snippet</a></h2>
<pre><code class="language-kt">class ScanRouterFragment : Fragment() {
  private val TAG = &quot;SCAN&quot;

  private var _binding: FragmentScanRouterBinding? = null
  private val binding get() = _binding!!

  private lateinit var db: DBHelper
  private lateinit var prefs: Prefs

  private var wifiScanReceiver: BroadcastReceiver? = null
  private lateinit var wifiManager: WifiManager
  private val routers = arrayListOf&lt;ArrayList&lt;Router?&gt;&gt;()
  private lateinit var session: Session
  private var pos: Pair&lt;Int, Int&gt; = Pair(-1, -1)
  private var cellSelected: TextView? = null

  override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View {
		// Connects the script to the elements in the xml file
    _binding = FragmentScanRouterBinding.inflate(inflater, container, false)
    val root: View = binding.root

    // Setup up prefs and default values
    db = DBHelper.getInstance(requireContext())!!
    prefs = Prefs.getInstance(requireContext())!!
    
    // Gets the current session from the preferences and stores it locally
    val lSession = db.getSessionById(prefs.getSession())

    if (lSession == null) {
      // Goes to the session screen if there are no sessions found
      findNavController().navigate(R.id.action_navigation_scan_routers_to_navigation_session)
      return root
    }
    
    // Sets the global reference to the local session
    session = lSession
    // Sets the row and column text fields of the matrix
    binding.etRow.setText(session.rows.toString())
    binding.etCol.setText(session.cols.toString())

    // Sets up the rest of the view
    setup()

    // Required by the method
    return root
  }

  private fun setup() {
    // Removes the existing routers listed
    binding.llRouters.removeAllViews()

    reset()
    setupWifiManager()
    setupRouters()
    setupGrid()
    setupListeners()
  }

  private fun reset() {
    // Clears the list of routers currently stored
    routers.clear()
    for (row in 0 until session.rows) {
      // Creates a list for the routers per row
      routers.add(ArrayList())
      for (col in 0 until session.cols) {
        // Fills the current column with null
        routers[row].add(null)
      }
    }

    // Removes the content of the grid layout
    binding.glRouterMatrix.removeAllViews()

    // Sets the grid layout according to the session
    binding.glRouterMatrix.rowCount = session.rows
    binding.glRouterMatrix.columnCount = session.cols
  }

  private fun setupWifiManager() {
    // Gets a reference to the Wifi Manager
    wifiManager = requireContext().getSystemService(Context.WIFI_SERVICE) as WifiManager
    if (!wifiManager.isWifiEnabled) {
      Toast.makeText(context, &quot;Enable your wifi&quot;, Toast.LENGTH_LONG).show()
    }

    // The receiver which detects the changes in the wifi
    wifiScanReceiver = object : BroadcastReceiver() {
      override fun onReceive(ctx: Context, intent: Intent) {
        // Checks if wifi scan is successful
        val success = intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)
        if (success) scanSuccess() else scanFailure()
      }
    }

    // Filters the amount of Intent that can be received
    val intentFilter = IntentFilter()
    // Adds the WifiManager.SCAN_RESULTS_AVAILABLE_ACTION
    // to the intents that will be received
    intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)
    // Registers the wifiScanReceiver with the intentFilter
    requireContext().registerReceiver(wifiScanReceiver, intentFilter)
  }

  private  fun setupRouters() {
    Log.d(TAG, &quot;Setup Routers&quot;)

    // Gets the session stored in the preferences
    val session = prefs.getSession()
    if (session == 0L) { return }
    // Gets the routers from the database
    val dbRouters = db.getSessionRouters(session)
    for (router in dbRouters) {
      // Populates the routers of the fragment
      // With the routers from the database
      routers[router.row][router.col] = router
    }
  }

  @SuppressLint(&quot;SetTextI18n&quot;)
  private fun setupGrid() {
    Log.d(TAG, &quot;Setup Grid&quot;)

    // Setup the Grid Buttons
    for (row in 0 until session.rows) {
      for (col in 0 until session.cols) {
        // Layout and Creation
        val tvCell = TextView(context)
        val params = GridLayout.LayoutParams(
          GridLayout.spec(GridLayout.UNDEFINED, 1, 1f),
          GridLayout.spec(GridLayout.UNDEFINED, 1, 1f)
        )

        tvCell.height = 128
        tvCell.width = ViewGroup.LayoutParams.WRAP_CONTENT

        tvCell.setBackgroundColor(if ((row + col) % 2 == 0) Color.RED else Color.BLUE)
        // Sets up what happens when a cell is clicked
        tvCell.setOnClickListener {
          if (cellSelected != null) {
            val (r, c) = pos
            cellSelected!!.setBackgroundColor(if ((r + c) % 2 == 0) Color.RED else Color.BLUE)
          }

          // Gets the current position of the cell
          pos = Pair(row, col)
          tvCell.setBackgroundColor(Color.WHITE)
          tvCell.setTextColor(Color.BLACK)
          // Sets the current cell to the selected cell
          cellSelected = tvCell
        }

        // Adds the cell to the matrix view
        binding.glRouterMatrix.addView(tvCell, params)

        // Text Formatting
        tvCell.foregroundGravity = Gravity.CENTER
        tvCell.gravity = Gravity.CENTER
        tvCell.textSize = 16f
        tvCell.typeface = Typeface.DEFAULT_BOLD
        tvCell.setTextColor(Color.WHITE)

        val router = routers[row][col]
        // Sets the label displayed on the cell to the name of the router
        val text = if (router != null) &quot;${router.getName()}\n${router.getBSSIDStr()}&quot; else &quot;NULL&quot;
        tvCell.text = text
      }
    }

    binding.glRouterMatrix.invalidate()
  }

  private fun setupListeners() {
    // Sets up what happens when the
    // Set Router Matrix button is clicked
    binding.btnSetMatrix.setOnClickListener {
      // Sets the row and column of the matrix
      // depending on the text selected
      val row = binding.etRow.text.toString().toInt()
      val col = binding.etCol.text.toString().toInt()
      Log.d(TAG, &quot;Pressed ($col, $row)&quot;)

      // Checks if the current rows and columns
      // are the same as the one saved in the current session
      // then changes it if it is different
      if (session.rows != row || session.cols != col) {
        session.rows = row
        session.cols = col

        // Updates the session in the database
        db.deleteSessionRows(session.id)
        db.deleteSessionRouters(session.id)
        db.updateSession(session)

        // Clears the routers
        reset()
        // Sets up the new grid layout
        setupGrid()
      }
    }

    // Sets up what happens when the Routers button is clicked
    binding.btnScanRouters.setOnClickListener {
      Log.d(TAG, &quot;Start Scanning&quot;)

      // The wifi manager starts scanning the network
      // This sends out the intent WifiManager.SCAN_RESULTS_AVAILABLE_ACTION
      // which creates the buttons for each router to be selected in scanSuccess
      val scanning = wifiManager.startScan()
      if (scanning) {
        // Clears the existing routers in the view
        binding.llRouters.removeAllViews()
        // Shows the progress bar
        binding.progressbar.visibility = View.VISIBLE
      } else {
        Toast.makeText(requireContext(),
          &quot;Could not start scan, Location might be off&quot;,
          Toast.LENGTH_LONG).show()
      }
    }
  }

  private fun scanSuccess() {
    Log.d(TAG, &quot;Scan Successful&quot;)

    // Hids the progress bar
    binding.progressbar.visibility = View.INVISIBLE
    val llRouters = binding.llRouters

    // Gets the results of the scan from the  wifiManager
    val results = wifiManager.scanResults
    for (result in results) {
      // Creates a button for each router
      val btn = Button(context)

      // Sets the name of the button according to the
      // name and address of the router
      val text = &quot;${result.SSID}&lt;${result.BSSID}&gt;&quot;
      btn.text = text

      // Sets up what happens when the router button is clicked
      btn.setOnClickListener {
        if (cellSelected == null) {
          return@setOnClickListener
        }

        // Retrieves the name and address of the router from the name of the button
        val (SSID, BSSID) = btn.text.subSequence(0, btn.text.length - 1).split(&quot;&lt;&quot;)
        // Sets the router row and column according to
        // the position of the selected cell in the grid
        val (r, c) = pos
        // Creates a new instance of the router using the name and address
        // retrieved from the button earlier
        val router = Router(BSSID, SSID)
        // Sets the row and column from the position
        router.row = r
        router.col = c

        val btnTxt = &quot;${router.getName()}\n${router.getBSSIDStr()}&quot;

        pos = Pair(-1, -1)

        routers[r][c] = router

        // Adds the router to the cell in the router matrix
        cellSelected!!.setBackgroundColor(if ((r + c) % 2 == 0) Color.RED else Color.BLUE)
        cellSelected!!.text = btnTxt

        cellSelected = null

        btn.isEnabled = false

        try {
          // Adds the router to the database
          db.addRouter(router.getBSSID(), router.getName())
          db.addSessionRouter(prefs.getSession(), router.getBSSID(), r, c)
        } catch (e: Exception) {
          Log.d(TAG,&quot;Could not add router&quot;)
        }
      }

      // Adds the router to the list view
      llRouters.addView(btn)
    }
  }

  private fun scanFailure() {
    Log.e(TAG, &quot;Scan Failed&quot;)
  }

  override fun onDestroyView() {
    super.onDestroyView()
    _binding = null

    // Deregister the wifiScanReceiver
    if (wifiScanReceiver != null) {
      requireContext().unregisterReceiver(wifiScanReceiver)
      wifiScanReceiver = null
    }
  }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-fragment"><a class="header" href="#data-fragment">Data Fragment</a></h1>
<p>The data fragment is where the data recorded in the <a href="chapters/views/homeFragment.html">Home Fragment</a> can be viewed, removed, imported, and exported.</p>
<h2 id="layout-2"><a class="header" href="#layout-2">Layout</a></h2>
<p><img src="https://i.imgur.com/XluMSz8.jpg" alt="" /></p>
<h2 id="snippet-22"><a class="header" href="#snippet-22">Snippet</a></h2>
<pre><code class="language-kt">class DataFragment : Fragment(), CellClickListener {
  private val TAG = &quot;DATA&quot;

  private var _binding: FragmentDataBinding? = null
  private val binding get() = _binding!!

  private lateinit var adapter: RecyclerViewAdapter

  private lateinit var db: DBHelper
  private lateinit var prefs: Prefs

  override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View {
    _binding = FragmentDataBinding.inflate(inflater, container, false)
    val root: View = binding.root

    // Gets the instance of the prefs and dbhelper
    prefs = Prefs.getInstance(requireContext())!!
    db = DBHelper.getInstance(requireContext())!!

    // Gets the current session saved to the device
    val session = prefs.getSession()
    db.printData(session) // DEBUG

    // Creates an empty list of RowData
    val data = arrayListOf&lt;RowData&gt;()
    if (session &gt; 0L) {
      // Loads the RowData for that session from the database
      data.addAll(db.getData(session))
    }

    // Sets up the display
    adapter = RecyclerViewAdapter(data, this)

    binding.rvDatapoints.adapter = adapter
    binding.rvDatapoints.layoutManager = LinearLayoutManager(requireContext())
    ItemTouchHelper(itemTouchHelperCallback).attachToRecyclerView(binding.rvDatapoints)

    // Sets up what happens when the Export CSV button is clicked
    binding.btnExport.setOnClickListener {
      // Creates a variable to store the csv with the first value being label
      var csv = &quot;label&quot;
      // Adds the names of the routers as to the csv
      for (router in db.getSessionRouters(prefs.getSession())) {
        csv += &quot;,&quot; + router.getBSSID() + &quot;-&quot; + router.getName()
      }
      // Creates a new line after going through the names of the routers
      csv += &quot;\n&quot;

      // Adds the label and accompanying RSSI values to the csv
      for (row in adapter.data) {
        csv += &quot;${row.label},${row.values.joinToString(&quot;,&quot;)}\n&quot;
      }

      // Saves the csv file
      write(csv, requireContext())
    }

    return root
  }

  private fun write(data: String, context: Context) {
    try {
      // Creates a file name based on when the data has been exported
      val name = &quot;${LocalDate.now()}T${LocalTime.now().toString().replace(&quot;:&quot;, &quot;-&quot;).replace(&quot;.&quot;, &quot;-&quot;)}&quot;
      // Saves the file to the device with the filename given
      val file =
        File(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), &quot;$name.csv&quot;)

      // Creates the file and prevents it from being written over
      val stream = FileOutputStream(file, false)
      stream.write(data.toByteArray())
      stream.flush()
      stream.close()

      // Notification that the file has been saved
      Toast.makeText(context,
        &quot;Saved to ${file.path}&quot;,
        Toast.LENGTH_LONG).show()



    } catch (e: Exception) {
      Log.e(TAG, e.toString())
    } finally {

    }
  }

  override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
  }

  private val itemTouchHelperCallback: ItemTouchHelper.SimpleCallback = object : ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.RIGHT) {
    override fun onMove(
      recyclerView: RecyclerView,
      viewHolder: RecyclerView.ViewHolder,
      target: RecyclerView.ViewHolder
    ): Boolean {
      return false
    }

    // Deletes the data when the entry is swiped
    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
      val pos = viewHolder.adapterPosition
      db.deleteRow(adapter.getRecordId(pos))
      adapter.removeItem(pos)
    }
  }

  // Allows the entry of the data to be edited
  @SuppressLint(&quot;NotifyDataSetChanged&quot;)
  override fun onCellClickListener(data: RowData) {
    // Create a dialog box
    val dialog = DataFormDialog(data)
    dialog.acceptListener = {
      val values = dialog.getValues()
      val updated = db.updateRow(prefs.getSession(), data.recordId, values)
      if (updated) {
        data.values.clear()
        data.values.addAll(values)

        binding.rvDatapoints.adapter?.notifyDataSetChanged()
      }
    }

    dialog.cancelListener = {}

    dialog.show(parentFragmentManager, &quot;Edit Data&quot;)
  }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="home-fragment"><a class="header" href="#home-fragment">Home Fragment</a></h1>
<p>The home fragment is where the data can be recorded and predicted based on the routers set up on the <a href="chapters/views/scanRouterFragment.html">Scan Router Fragment</a>.</p>
<h2 id="layout-3"><a class="header" href="#layout-3">Layout</a></h2>
<p><img src="https://i.imgur.com/kJ5omXX.jpg" alt="" /></p>
<h2 id="snippet-23"><a class="header" href="#snippet-23">Snippet</a></h2>
<pre><code class="language-kt">class HomeFragment : Fragment() {

  private var _binding: FragmentHomeBinding? = null

  private val TAG = &quot;HOME&quot;

  private lateinit var db: DBHelper
  private lateinit var prefs: Prefs
  private var wifiReceiver: BroadcastReceiver? = null
  private lateinit var wifiManager: WifiManager

  // HashMap &lt;BSSID, Router&gt;
  private val routers = hashMapOf&lt;Long, Router&gt;()
  private val knnClassifier: KNNClassifier = KNNClassifier()
  private val outputMatrix = arrayListOf&lt;ArrayList&lt;TextView&gt;&gt;()
  private lateinit  var _context: Context

  var capacity: Int = 0
  var label: Int = 0
  private lateinit var session: Session

  // Determines the state of the application
  private enum class State {
    RECORDING,
    PREDICTING,
    NONE
  }
  private var state = State.NONE

  // This property is only valid between onCreateView and
  // onDestroyView.
  private val binding get() = _binding!!

  override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View {
    _binding = FragmentHomeBinding.inflate(inflater, container, false)
    val root: View = binding.root

    // Gets the instance of the prefs and dbhelper
    prefs = Prefs.getInstance(requireContext())!!
    db = DBHelper.getInstance(requireContext())!!
    // Gets the session from the database
    val lSession = db.getSessionById(prefs.getSession())
    // Gets the capacity from the preferences
    capacity = prefs.getCapacity()

    // Sets the text in the capacity field to the current capacity
    binding.etCapacity.setText(capacity.toString())

    _context = requireContext()

    // Checks if there is a session saved and opens the session fragment if there is none
    if (lSession == null) {
      findNavController().navigate(R.id.action_navigation_home_to_navigation_session)
      return root
    }

    // Sets the global session to the current session
    session = lSession
    // Sets up the other components
    setup()

    return root
  }

  private fun setup() {
    setupWifiManager()
    setupListeners()
    setupGrid()
    setupKNN()
  }

  // Similar to how the wifi manager is setup in Scan Router Fragment
  private fun setupWifiManager() {
    wifiManager = requireContext().getSystemService(Context.WIFI_SERVICE) as WifiManager
    if (!wifiManager.isWifiEnabled) {
      Toast.makeText(context, &quot;Enable your wifi&quot;, Toast.LENGTH_LONG).show()
    }

    wifiReceiver = object : BroadcastReceiver() {
      override fun onReceive(ctx: Context, intent: Intent) {
        enableButtons()
        val success = intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)
        if (success) scanSuccess() else scanFailure()
      }
    }

    val intentFilter = IntentFilter()
    intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)
    requireContext().registerReceiver(wifiReceiver, intentFilter)
  }

  private fun setupListeners() {
    // Text Changes
    // Saves the new capacity to the preferences
    // when it has been changed in the input field
    binding.etCapacity.doOnTextChanged { text, _, _, _ -&gt;
      val t = text.toString()
      if (t != &quot;&quot;) {
        capacity = t.toInt()
        prefs.setCapacity(capacity)
      }
    }

    // Saves the new label to the preferences
    // when it has been changed in the input field
    binding.etLabel.doOnTextChanged { text, _, _, _ -&gt;
      val t = text.toString()
      if (t != &quot;&quot;) {
        val i = t.toInt()
        label = i
      }
    }

    // Button Clicks
    // Sets what happens when the Record button is clicked
    binding.btnRecord.setOnClickListener {
      setupScan()

      state = State.RECORDING
    }

    // Sets what happens when the Predict button is clicked
    binding.btnScanning.setOnClickListener {
      setupScan()

      state = State.PREDICTING
    }
  }

  // Sets up the router matrix visual similar to the Scan Router Fragment
  private fun setupGrid() {
    // Clear values
    binding.glOutputMatrix.removeAllViews()
    outputMatrix.clear()

    binding.glOutputMatrix.rowCount = session.rows
    binding.glOutputMatrix.columnCount = session.cols

    // setupScan the Grid Buttons
    for (row in 0 until session.rows) {
      outputMatrix.add(arrayListOf())
      for (col in 0 until session.cols) {
        val tv = TextView(context)
        val params = GridLayout.LayoutParams(
          GridLayout.spec(GridLayout.UNDEFINED, 1, 1f),
          GridLayout.spec(GridLayout.UNDEFINED, 1, 1f)
        )

        tv.height = 128
        tv.width = ViewGroup.LayoutParams.WRAP_CONTENT
        tv.setBackgroundColor(if ((row + col) % 2 == 0) Color.RED else Color.BLUE)
        tv.text = &quot;0&quot; // TODO: Check if the router is set else set this to not configured
        tv.textSize = 32f
        tv.typeface = Typeface.DEFAULT_BOLD
        tv.gravity = Gravity.CENTER

        binding.glOutputMatrix.addView(tv, params)
        outputMatrix[row].add(tv)
      }
    }
  }

  private fun setupKNN() {
    // Gets the current session saved in the device
    val session = prefs.getSession()
    if (session == 0L) {
      // Does not continue if there are no sessions found
      return
    }

    // Loads the data of the session from the database to the KNN Classifier class
    knnClassifier.loadMatrix(db.getData(session))
  }

  private fun enableButtons() {
    binding.btnRecord.isEnabled = true
    binding.btnScanning.isEnabled = true
  }

  private fun resetGridText() {
    for (row in 0 until session.rows) {
      for (col in 0 until session.cols) {
        outputMatrix[row][col].text = &quot;0&quot;
      }
    }
  }

  @SuppressLint(&quot;SetTextI18n&quot;)
  private fun disableButtons() {
    binding.tvMessage.text = &quot;&quot;
    binding.tvMessage.setBackgroundColor(Color.TRANSPARENT)

    binding.btnRecord.isEnabled = false
    binding.btnScanning.isEnabled = false
  }

  /**
   * Setups the routers then initiates the scans
   */
  private fun setupScan() {
    resetGridText()
    disableButtons()

    val handler = Handler()
    // Executes the code within after a certain amount of time
    handler.postDelayed({
      // Clears the existing list of routers
      routers.clear()

      // Gets the current session from the device
      val session = prefs.getSession()
      if (session &gt; 0L) {
        // Gets routers from the database for the session
        val dbRouters = db.getSessionRouters(session)
        for (router in dbRouters) {
          // Sets the routers in the view with the routers from the database
          routers[router.getBSSID()] = router
        }
        // Sets the input size of the knn classifier to the number of routers
        knnClassifier.inputSize = routers.size

        if (!wifiManager.startScan()) {
          enableButtons()
        }
      }
    }, 2500) // 2.5 sec delay
  }

  @SuppressLint(&quot;SetTextI18n&quot;)
  private fun scanSuccess() {
    binding.tvMessage.text = &quot;Scan Successful&quot;
    binding.tvMessage.setBackgroundColor(Color.GREEN)

    // Gets the results of the wifi scan
    val results = wifiManager.scanResults

    when (state) {
      // Sets up what happens when the state is set to predicting
      State.PREDICTING -&gt; {
        // Creates a float array to store the RSSI values
        val vector = FloatArray(routers.size)
        for (result in results) {
          // Grabs a router from the results of the wifiManager
          var router = Router(result.BSSID, result.SSID)
          if (routers.contains(router.getBSSID()) &amp;&amp; routers[router.getBSSID()] != null) {
            // Gets the RSSI value of the router and adds it to the vector
            router = routers[router.getBSSID()]!!
            val dbm = result.level
            vector[router.row * session.cols + router.col] = dbm.toFloat()

            // Displays the RSSI value in the router matrix in the home fragment view
            outputMatrix[router.row][router.col].text = dbm.toString()
          }
        }

        // Runs the predict method of the knnClassifier and collects the
        // amount of occupied vehicles detected for the set of RSSI values stored in vector
        val prediction = knnClassifier.predict(vector.toCollection(ArrayList()))
        Log.i(TAG, &quot;Capacity: $capacity ; Prediction: $prediction&quot;)
        // Displays the amount of occupied vehicles in the home view
        binding.tvOccupied.text = &quot;Occupied: $prediction&quot;
        // Displays the amount of unoccupied vehicles in the home view
        binding.tvUnoccupied.text = &quot;Unoccupied: ${capacity - prediction}&quot;

        state = State.NONE
      }
      // Sets up what happens when the state is set to recording
      State.RECORDING -&gt; {
        // Creates a float array to store the RSSI values
        val vector = FloatArray(routers.size)
        // Creates a hashmap to store the router id and its associated RSSI value
        val values = hashMapOf&lt;Long, Float&gt;()
        // Initializes the hashmap
        for ((key, _) in routers) {
          values[key] = 0f
        }

        for (result in results) {
          var router = Router(result.BSSID, result.SSID)
          if (routers.contains(router.getBSSID()) &amp;&amp; routers[router.getBSSID()] != null) {
            // Grabs a router from the results of the wifiManager
            router = routers[router.getBSSID()]!!
            // Gets the RSSI value of the router and adds it to the vector
            val dbm = result.level.toFloat()
            vector[router.row * session.cols + router.col] = dbm

            // Displays the RSSI value in the router matrix in the home fragment view
            outputMatrix[router.row][router.col].text = &quot;$dbm dbm&quot;
            // Pairs the RSSI value with the router
            values[router.getBSSID()] = dbm
          }
        }

        Log.d(TAG, &quot;HELLO&quot;)
        Log.d(TAG, values.toString())

        Log.d(TAG, &quot;Vector: ${vector.joinToString(&quot;, &quot;, &quot;[ &quot;, &quot; ]&quot;)} ; Label: $label&quot;)

        // Adds the point to the knn classifier with the paired label
        knnClassifier.addPoint(
          vector.toCollection(ArrayList()),
          label
        )

        // Adds the points as a row in the database
        db.addRow(prefs.getSession(), label, values)
        state = State.NONE
      }
      else -&gt; { /* Do nothing */ }
    }

    Log.d(TAG, &quot;Scan successful&quot;)
  }

  private fun scanFailure() {
    binding.tvMessage.text = &quot;Scan Failed&quot;
    binding.tvMessage.setBackgroundColor(Color.RED)
  }

  override fun onDestroyView() {
    super.onDestroyView()
    _binding = null

    if (wifiReceiver != null) {
      requireContext().unregisterReceiver(wifiReceiver)
      wifiReceiver = null
    }
  }
}

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
