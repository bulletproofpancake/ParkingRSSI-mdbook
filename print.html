<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ParkingRSSI Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="chapters/applicationOverview.html">Application Overview</a></li><li class="chapter-item expanded affix "><a href="chapters/projectStructure.html">Project Structure</a></li><li class="chapter-item expanded affix "><li class="part-title">Scripts</li><li class="chapter-item expanded "><a href="chapters/knn-classifier.html"><strong aria-hidden="true">1.</strong> KNN Classifier</a></li><li class="chapter-item expanded "><a href="chapters/router.html"><strong aria-hidden="true">2.</strong> Router</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ParkingRSSI Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="application-overview"><a class="header" href="#application-overview">Application Overview</a></h1>
<p>This Smart Parking System uses the K-Nearest Neighbors (KNN) algorithm in order to calculate the amount of available parking spaces
using Received Signal Strength Indicator (RSSI) values.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<h3 id="plotting-the-points"><a class="header" href="#plotting-the-points">Plotting the points</a></h3>
<p>In this program, the K-Nearest Neighbors (KNN) algorithm is implemented by collecting the Received Signal Strength Indicator (RSSI) values
of a parking lot with a set amount of cars. This can be visualized in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>Number of Cars</th><th>RSSI Values</th></tr></thead><tbody>
<tr><td>0</td><td>-30.0, -27.0</td></tr>
<tr><td>1</td><td>-22.0, -27.0</td></tr>
<tr><td>1</td><td>-26.0, -24.0</td></tr>
<tr><td>1</td><td>-29.0, -25.0</td></tr>
<tr><td>1</td><td>-32.0, -23.0</td></tr>
</tbody></table>
</div>
<p>And this is how it can be seen in a graph:</p>
<p><img src="https://i.imgur.com/nZFeIgk.png" alt="" /></p>
<p>When the app is used to check how many parking spaces are still available, it compares the current RSSI values to the existing data.</p>
<p>Let us say for example that we used the app and got the following data:</p>
<div class="table-wrapper"><table><thead><tr><th>Number of Cars</th><th>RSSI Values</th></tr></thead><tbody>
<tr><td>?</td><td>-30.0, -22.0</td></tr>
</tbody></table>
</div>
<p>And in a graph, it appears like this in accordance with the existing data:</p>
<p><img src="https://i.imgur.com/OpzUjGu.png" alt="" /></p>
<h3 id="the-k-value"><a class="header" href="#the-k-value">The k-value</a></h3>
<p>Now that we have our point, this is where the value of <code>k</code> comes into place. <code>k</code> is the number of neighboring points we compare to in order to
classify our point. Remember that each category is the amount of cars for that set of RSSI values.</p>
<blockquote>
<p>By default, the value of <code>k</code> in the program is 3. This means that the algorithm only compares the current point to 3 neighboring points.
Increasing the value of <code>k</code> is better for accuracy, at the cost of speed.
In this example, the classification of the point has changed depending on the value of the <code>k</code>:
<img src="https://helloacm.com/wp-content/uploads/2016/03/2012-10-26-knn-concept.png" alt="" /></p>
</blockquote>
<h3 id="getting-the-nearest-points"><a class="header" href="#getting-the-nearest-points">Getting the nearest points</a></h3>
<p>Now that we have our k value, it is time to get our nearest neighbors.
In order to get the distance from the current point to the neighboring points, the program uses the Euclidean Distance formula:</p>
<p>\[ d(p,q) = \sqrt {\sum_{i=1}^n (q_i - p_i)^2}  \]</p>
<p>where:</p>
<ul>
<li>\(p, q\) = two points in Euclidean n-space</li>
<li>\(q_i, p_i\) = Euclidean vectors, starting from the origin of the space (initial point)</li>
<li>\(n\) = n-space</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> If this looks complex, it is similar to calculating the length of the hypothenuse in a triangle (Pythagorean Theorem).
\[hypothenuse = \sqrt{{leg_1}^2 + {leg_2}^2}\]
I recommend studying more Vector maths in order to get a better understanding of Euclidean Distance.</p>
</blockquote>
<p>In our program, calculating the distances can be visualized as such in accordance with the existing data:</p>
<ul>
<li>\(p\) = coordinates of the current point</li>
<li>\(q\) = coordinates of the point of a neighbor. I will be using the amount of cars as the label for clarity.</li>
<li>\(d\) = distance between our points</li>
</ul>
<blockquote>
<p>Do take note that adding more routers would only mean adding more rows to the table,
however it would be more difficult to visualize in a 2D graph like the ones presented in this document.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (0)</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-30.0</td><td>\(\sqrt{(-30.0 + 30.0)^2}\)</td><td>0</td></tr>
<tr><td>-22.0</td><td>-27.0</td><td>\(\sqrt{(-27.0 + 22.0)^2}\)</td><td>5</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_0 = 0 + 5 = 5\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_0\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-22.0</td><td>\(\sqrt{(-22.0 + 30.0)^2}\)</td><td>8</td></tr>
<tr><td>-22.0</td><td>-27.0</td><td>\(\sqrt{(-27.0 + 22.0)^2}\)</td><td>5</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_1 = 8 + 5 = 13\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_1\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-26.0</td><td>\(\sqrt{(-26.0 + 30.0)^2}\)</td><td>4</td></tr>
<tr><td>-22.0</td><td>-24.0</td><td>\(\sqrt{(-24.0 + 22.0)^2}\)</td><td>2</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_2 = 4 + 2 = 6\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_2\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-29.0</td><td>\(\sqrt{(-29.0 + 30.0)^2}\)</td><td>1</td></tr>
<tr><td>-22.0</td><td>-25.0</td><td>\(\sqrt{(-25.0 + 22.0)^2}\)</td><td>3</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_3 = 1 + 3 = 4\]</p>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q (\(1_3\))</th><th>Equation</th><th>d</th></tr></thead><tbody>
<tr><td>-30.0</td><td>-32.0</td><td>\(\sqrt{(-32.0 + 30.0)^2}\)</td><td>2</td></tr>
<tr><td>-22.0</td><td>-23.0</td><td>\(\sqrt{(-23.0 + 22.0)^2}\)</td><td>1</td></tr>
</tbody></table>
</div>
<p>\[\sum d(p,q)_4 = 2 + 1 = 3\]</p>
<p>After we calculate the distances for each point, we can visualize them like so:</p>
<div class="table-wrapper"><table><thead><tr><th>Amount of Cars</th><th>Index</th><th>Distance</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>5</td></tr>
<tr><td>1</td><td>1</td><td>13</td></tr>
<tr><td>1</td><td>2</td><td>6</td></tr>
<tr><td>1</td><td>3</td><td>4</td></tr>
<tr><td>1</td><td>4</td><td>3</td></tr>
</tbody></table>
</div>
<p>At this point, we only have the distances to other points, but we do not know yet the nearest neighbors.
In order to get the nearest neighbors, all we need to do is to sort the distances like so:</p>
<div class="table-wrapper"><table><thead><tr><th>Amount of Cars</th><th>Index</th><th>Distance</th></tr></thead><tbody>
<tr><td>1</td><td>4</td><td>3</td></tr>
<tr><td>1</td><td>3</td><td>4</td></tr>
<tr><td>0</td><td>0</td><td>5</td></tr>
<tr><td>1</td><td>2</td><td>6</td></tr>
<tr><td>1</td><td>1</td><td>13</td></tr>
</tbody></table>
</div>
<p>Now that the distances have been sorted, the nearest neighbors can now be gathered in accordance with the <code>k</code> value.
Since the default of <code>k</code> is 3, the nearest points would be the following:</p>
<div class="table-wrapper"><table><thead><tr><th>Amount of Cars</th><th>Index</th><th>Distance</th><th>RSSI Values</th></tr></thead><tbody>
<tr><td>1</td><td>4</td><td>3</td><td>-32.0, -23.0</td></tr>
<tr><td>1</td><td>3</td><td>4</td><td>-29.0, -25.0</td></tr>
<tr><td>0</td><td>0</td><td>5</td><td>-30.0, -27.0</td></tr>
</tbody></table>
</div>
<p>In a graph, it can be visualized like so:
<img src="https://i.imgur.com/b7MSijK.png" alt="" /></p>
<p>Because there is only 1 point that has zero cars, and 2 points that have one car,
according to the KNN algorithm, the RSSI values of the current point (-30, -22) would state that
there is 1 parking slot occupied.</p>
<p><img src="https://i.imgur.com/O8n6Szo.png" alt="" /></p>
<p>This means that in a parking lot of 10 slots, there is 1 occupied slot and 9 available slots.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>The project consists of two major components, the source code and the layout files.
Source code files end in <code>.kt</code> while layout files end in <code>.xml</code>.
Source code files are responsible for the logic of the app
while layout files are responsible for the interface.</p>
<h2 id="source-code-directories"><a class="header" href="#source-code-directories">Source Code Directories</a></h2>
<p>When the project is opened in Android Studio, there is a file explorer located in the left portion of the screen by default named <code>Project</code>.
Ensure that <code>Android</code> is selected on the tab on the top as it is a simple layout to navigate.
Under <code>app</code>, expand the <code>java</code> folder, and <code>com.silentrald.parkingrssi</code>.
All the files inside this folder contains the source code for the project.</p>
<p><img src="https://i.imgur.com/gmHlPxZ.gif" alt="" /></p>
<h3 id="descriptions"><a class="header" href="#descriptions">Descriptions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Folder</th><th>File</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>interfaces</strong></td><td></td><td>Contains <a href="https://kotlinlang.org/docs/interfaces.html">interfaces</a> which will be used by the other classes.</td></tr>
<tr><td></td><td>CellClickListener</td><td></td></tr>
<tr><td><strong>models</strong></td><td></td><td>Contains the <a href="https://kotlinlang.org/docs/classes.html">classes</a> needed by the program to create and train the model for the neural network.</td></tr>
<tr><td></td><td>DBHelper</td><td>Contains methods in order to create an <a href="https://www.geeksforgeeks.org/android-sqlite-database-in-kotlin/"><code>SQLite Database</code></a> for recording information about the routers and sessions.</td></tr>
<tr><td></td><td>Prefs</td><td>Contains information to save the session and capacity to the device.</td></tr>
<tr><td></td><td>RowData</td><td>Contains the number of cars occupied for a set of RSSI values.</td></tr>
<tr><td></td><td>Session</td><td>Contains the setup of how the model is trained.</td></tr>
<tr><td><strong>views</strong></td><td></td><td>Contains the classes to interact with the different screens of the application.</td></tr>
<tr><td></td><td>DataFormDialog</td><td></td></tr>
<tr><td></td><td>DataFragment</td><td></td></tr>
<tr><td></td><td>HomeFragment</td><td></td></tr>
<tr><td></td><td>RecyclerViewAdapter</td><td></td></tr>
<tr><td></td><td>ScanRouterFragment</td><td></td></tr>
<tr><td></td><td>SessionFragment</td><td></td></tr>
<tr><td><strong>-</strong></td><td></td><td>The classes found on the root of <code>com.silentrald.parkingrssi</code></td></tr>
<tr><td></td><td>KNNClassifier</td><td>Contains the logic implementing the <a href="https://bit.ly/2OcMqHv">K-Nearest Neighbor Algorithm</a>.</td></tr>
<tr><td></td><td>MainActivity</td><td>Controls the navigation of the program.</td></tr>
<tr><td></td><td>Router</td><td>Contains methods in order for the program to view and record routers.</td></tr>
</tbody></table>
</div>
<h2 id="layout-directories"><a class="header" href="#layout-directories">Layout Directories</a></h2>
<p>The layout directories contain the files that create the user interface of the application.
It also contains the ids of each component which would be used by the scripts in the <code>views</code> directory.
The layouts are stored in <code>app &gt; res &gt; layout</code>.</p>
<p><img src="https://i.imgur.com/0NBqEqH.png" alt="" /></p>
<h3 id="descriptions-1"><a class="header" href="#descriptions-1">Descriptions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>File</th><th>Description</th></tr></thead><tbody>
<tr><td>activity_main.xml</td><td>Contains a navigation bar and where the fragment gets displayed.</td></tr>
<tr><td>fragment_data.xml</td><td>Contains a list of recordings of the RSSI values and buttons to import and export csv files.</td></tr>
<tr><td>fragment_home.xml</td><td>Contains the interface needed to train the model and predict the amount of vehicles in the parking slot.</td></tr>
<tr><td>fragment_scan_router.xml</td><td>Contains a menu to select the routers to be recorded.</td></tr>
<tr><td>fragment_session.xml</td><td>Contains a list of sessions to be loaded.</td></tr>
<tr><td>layout_data_form.xml</td><td></td></tr>
<tr><td>layout_data_row.xml</td><td></td></tr>
<tr><td>layout_data_value_input.xml</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="knn-classifier"><a class="header" href="#knn-classifier">KNN Classifier</a></h1>
<p>The <code>KNN Classifier</code> class contains the logic implementing the <a href="https://bit.ly/2OcMqHv">K-Nearest Neighbor Algorithm</a>.
It is located at <code>app &gt; java &gt; com.silentrald.parkingrssi &gt; KNNClassifier.kt</code>.
This page is for explaining the source code of how the algorithm is implemented.
For a more high level overview, please refer to the <a href="chapters/applicationOverview.html">Application Overview</a>.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>The <code>KNN Classifier</code> class has multiple fields which are needed in order to calculate the number of available parking spaces
using the algorithm.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>k</td><td><code>var k: Int = 3</code></td><td>The number of neighbors to be evaluated by the algorithm. The value is set to 3 by default.</td></tr>
<tr><td>inputSize</td><td><code>var inputSize: Int = 6</code></td><td>The number of routers to get RSSI values from.</td></tr>
<tr><td>matrix</td><td><code>val matrix = arrayListOf&lt;ArrayList&lt;Float&gt;&gt;()</code></td><td>A collection of RSSI values gathered from the routers.</td></tr>
<tr><td>labels</td><td><code>val labels = arrayListOf&lt;Int&gt;()</code></td><td>A collection of the amount of cars for a set of RSSI values.</td></tr>
</tbody></table>
</div>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="addpoint"><a class="header" href="#addpoint">addPoint</a></h3>
<p>The <code>addPoint</code> method adds a point to the dataset. This point contains the RSSI values and the amount of cars for that set.</p>
<h4 id="snippet"><a class="header" href="#snippet">Snippet</a></h4>
<pre><code class="language-kt">fun addPoint(point: ArrayList&lt;Float&gt;, label: Int) {
    if (point.size != inputSize) {
      return
    }

    matrix.add(point)
    labels.add(label)

    k = sqrt(matrix.size.toDouble()).toInt()
  }
</code></pre>
<h4 id="parameters"><a class="header" href="#parameters">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>point</td><td><code>point: ArrayList&lt;Float&gt;</code></td><td>The RSSI values received from the routers.</td></tr>
<tr><td>label</td><td><code>label: Int</code></td><td>The amount of cars in the parking lot when the point is recorded.</td></tr>
</tbody></table>
</div>
<h4 id="implementation"><a class="header" href="#implementation">Implementation</a></h4>
<p>At the start of the method, the size of the point is compared to the <code>inputSize</code>.
Each router sends a single RSSI value which is contained as a list in the <code>point</code> variable.
This check then is to ensure that all routers have sent an RSSI value before it is added to the database.</p>
<pre><code class="language-kt">// For example:
// point = {-27.0,-36.0,-20.0,-27.0,-31.0}

// Given that there are 5 entries in point:
// point.size = 5

// inputSize is based on the amount of routers selected.
// Given that each router sends a single RSSI value:
// inputSize = 5

// Because the point.size and inputSize is the same
// the method would not return and continue to the next step

if (point.size != inputSize){
    return
}
</code></pre>
<p>If the <code>point</code> entered is valid, it gets added to the <code>matrix</code> and the <code>label</code> gets added to the <code>labels</code>.
In essence, this &quot;pairs&quot; the <code>label</code> with the <code>point</code> entered as they share the same index as they get added to their lists at the same time.</p>
<pre><code class="language-kt">// For example:
// point = {-27.0,-36.0,-20.0,-27.0,-31.0}
// label = 0
// matrix = {}
// labels = {}

// The reason matrix is empty is because there are no points added to it yet.
// labels is empty for the same reason.

matrix.add(point)

// matrix = [{-27.0,-36.0,-20.0,-27.0,-31.0}]

// After adding the point, the matrix now contains the list of RSSI values from the point.
// This is why in the declaration of the matrix, it is an arrayListof&lt;ArrayList&lt;Float&gt;&gt;()
// The matrix is a list for a list of float variables.

labels.add(label)

// labels = {0}

// After adding the label, the labels list now contain the value of the label.
</code></pre>
<p>Once the <code>point</code> and <code>label</code> has been added to the database, the value of <code>k</code> is adjusted.</p>
<pre><code class="language-kt">// For example, another point has been added to the matrix:
// matrix = [{-27.0,-36.0,-20.0,-27.0,-31.0}, -26.0,-37.0,-20.0,-28.0,-30.0}]
// matrix.size = 2
// matrix.size.toDouble = 2.0
// sqrt(matrix.size.toDouble()) = 1.41421356237309511.0
// sqrt(matrix.size.toDouble()).toInt() = 1

k = sqrt(matrix.size.toDouble()).toInt()

// By doing this, the points gets compared to more neighbors as it increases.
</code></pre>
<p>As mentioned before, this &quot;pairs&quot; the <code>point</code> and <code>label</code> together.
For example, the data collected from five routers can be presented in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>label</th><th>66852627208993-xiaomi-repeater-v3_miapdb21</th><th>66852627204643-xiaomi-repeater-v3_miapca23</th><th>66852627209260-xiaomi-repeater-v3_miapdc2c</th><th>66852627198541-xiaomi-repeater-v3_miapb24d</th><th>66852627208795-xiaomi-repeater-v3_miapda5b</th></tr></thead><tbody>
<tr><td>0</td><td>-27.0</td><td>-36.0</td><td>-20.0</td><td>-27.0</td><td>-31.0</td></tr>
<tr><td>1</td><td>-26.0</td><td>-37.0</td><td>-20.0</td><td>-28.0</td><td>-30.0</td></tr>
<tr><td>2</td><td>-25.0</td><td>-43.0</td><td>-18.0</td><td>-29.0</td><td>-31.0</td></tr>
<tr><td>3</td><td>-26.0</td><td>-39.0</td><td>-21.0</td><td>-27.0</td><td>-32.0</td></tr>
<tr><td>4</td><td>-26.0</td><td>-39.0</td><td>-24.0</td><td>-25.0</td><td>-31.0</td></tr>
<tr><td>5</td><td>-25.0</td><td>-41.0</td><td>-25.0</td><td>-23.0</td><td>-31.0</td></tr>
</tbody></table>
</div>
<p>However, in the code these data are stored in two different lists, the <code>matrix</code> and <code>labels</code>, and they can be represented like so:</p>
<pre><code class="language-json">[
  {
    &quot;labels&quot;: &quot;{0,1,2,3,4,5}&quot;,
    &quot;matrix&quot;: &quot;{-27.0,-36.0,-20.0,-27.0,-31.0},{-26.0,-37.0,-20.0,-28.0,-30.0},{-25.0,-43.0,-18.0,-29.0,-31.0},{-26.0,-39.0,-21.0,-27.0,-32.0},{-26.0,-39.0,-24.0,-25.0,-31.0},{-25.0,-41.0,-25.0,-23.0,-31.0}&quot;
  }
]
</code></pre>
<p>Or in a table like so:</p>
<div class="table-wrapper"><table><thead><tr><th>labels</th><th>matrix</th></tr></thead><tbody>
<tr><td>0</td><td>{-27.0,-36.0,-20.0,-27.0,-31.0}</td></tr>
<tr><td>1</td><td>{-26.0,-37.0,-20.0,-28.0,-30.0}</td></tr>
<tr><td>2</td><td>{-25.0,-43.0,-18.0,-29.0,-31.0}</td></tr>
<tr><td>3</td><td>{-26.0,-39.0,-21.0,-27.0,-32.0}</td></tr>
<tr><td>4</td><td>{-26.0,-39.0,-24.0,-25.0,-31.0}</td></tr>
<tr><td>5</td><td>{-25.0,-41.0,-25.0,-23.0,-31.0}</td></tr>
</tbody></table>
</div>
<h3 id="calculatedistance"><a class="header" href="#calculatedistance">calculateDistance</a></h3>
<p>The <code>calculateDistance</code> method aggregates the distance between two collections of RSSI values.
In the app, one collection is from the current RSSI values received by the device
and another is from the existing RSSI values added to the <code>matrix</code>.
This is because the <code>calculateDistance</code> method is used when the app is <a href="chapters/knn-classifier.html#predict">predicting</a>.</p>
<p>It helps to think of each collection of RSSI values as a coordinate, however as the number of routers increase
so too does the dimensions in which these coordinates exist, which is why the Euclidean Distance formula is used to
calculate the distance between each point.</p>
<blockquote>
<p><strong>NOTE:</strong>
For a further in-depth breakdown of the usage of the Euclidean Distance formula,
please refer to the <a href="chapters/applicationOverview.html#getting-the-nearest-points">Getting the nearest points</a>
section in the Application Overview.</p>
</blockquote>
<h4 id="snippet-1"><a class="header" href="#snippet-1">Snippet</a></h4>
<pre><code class="language-kt">private fun calculateDistance(ps1: ArrayList&lt;Float&gt;, ps2: ArrayList&lt;Float&gt;): Float {
    if (ps1.size != ps2.size) return -1f

    var distance = 0f
    for (i in 0 until ps1.size) {
      distance += (ps1[i] - ps2[i]).pow(2) // (x1 - x2) ^ 2
    }
    return distance
  }
</code></pre>
<h4 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>ps1</td><td><code>ps1: ArrayList&lt;Float&gt;</code></td><td>The current RSSI values being detected by the device.</td></tr>
<tr><td>ps2</td><td><code>ps2: ArrayList&lt;Float&gt;</code></td><td>The RSSI values from the <code>matrix</code>.</td></tr>
</tbody></table>
</div>
<h4 id="returns"><a class="header" href="#returns">Returns</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Returns</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>distance</td><td><code>Float</code></td><td>The aggregated distance between the two collections of RSSI values.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h4>
<pre><code class="language-kt">// Compare the sizes of the parameters to check if it is valid.
// Returning a negative distance would mean that the parameters are invalid.
if(ps1.size != ps2.size) return -1f

// The next line creates a variable distance.
// This is where the aggregated distances will be stored and returned.
var distance = 0f

// The next line states that until the index reaches the size of ps1,
// the Euclidean Distance of the two points would be added to distance.
for (i in 0 until ps1.size){
    distance += (ps1[i] - ps2[i]).pow(2)
}

// Once the loop is finished, the distance would be returned.
return distance
</code></pre>
<h3 id="predict"><a class="header" href="#predict">predict</a></h3>
<p>The <code>predict</code> method is where the actual implementation of the K-Nearest Neighbor algorithm as it predicts
the amount of cars taken with the <code>point</code> given to it.</p>
<h4 id="snippet-2"><a class="header" href="#snippet-2">Snippet</a></h4>
<pre><code class="language-kt">fun predict(point: ArrayList&lt;Float&gt;): Int {
    val distances = arrayListOf&lt;Pair&lt;Float, Int&gt;&gt;()
    for (i in 0 until matrix.size) {
      distances.add(Pair(calculateDistance(point, matrix[i]), labels[i]))
    }

    distances.sortWith(compareBy { it.first })
    Log.i(&quot;KNN&quot;, distances.toString())

    val hashmap = hashMapOf&lt;Int, Int&gt;()

    var end = k.coerceAtMost(matrix.size)
    for (i in 0 until end) {
      val classification = distances[i].second
      hashmap[classification] = hashmap.getOrDefault(classification, 0) + 1
    }

    // Get Max (Plurality)
    var max = -1
    val outputs = arrayListOf&lt;Int&gt;()
    for ((key, value) in hashmap) {
      if (value &gt; max) {
        max = value
        outputs.clear()
        outputs.add(key)
      } else if (value == max) {
        outputs.add(key)
      }
    }

    if (outputs.size == 1) {
      return outputs[0]
    }

    // Tie-breaking
    while (end &gt; 0) {
      end--
      val classification = distances[end].second
      hashmap[classification]?.dec()

      max = -1
      outputs.clear()
      for ((key, value) in hashmap) {
        if (value &gt; max) {
          max = value
          outputs.clear()
          outputs.add(key)
        } else if (value == max) {
          outputs.add(key)
        }
      }

      if (outputs.size == 1) {
        return outputs[0]
      }
    }

    // Just return the first one
    return distances[0].second
  }
</code></pre>
<h4 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameters</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>point</td><td><code>ArrayList&lt;Float&gt;</code></td><td>The current RSSI values being detected by the device.</td></tr>
</tbody></table>
</div>
<h4 id="returns-1"><a class="header" href="#returns-1">Returns</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Returns</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>outputs[0]</td><td><code>Int</code></td><td>The largest <code>label</code> recorded in the database.</td></tr>
<tr><td>distances[0].second</td><td><code>Int</code></td><td>The <code>label</code> of the nearest neighbor to the <code>point</code>.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h4>
<p>At the start of the <code>predict</code> method, a List of a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/"><code>Pair</code></a>
of types <code>Float</code> and <code>Int</code> are created and stored in the variable <code>distances</code>.
The <code>Float</code> is responsible for containing the distance from the <code>point</code> to the existing points added in the database,
while the <code>Int</code> contains the amount of cars expected for the point according to the database.</p>
<pre><code class="language-kt">val distances = arrayListOf&lt;Pair&lt;Float, Int&gt;&gt;()

for (i in 0 until matrix.size){
  distances.add(Pair(calculateDistance(point,matrix[i]), labels[i]))
}
</code></pre>
<p>For example, the given data is the following:</p>
<pre><code>label = {2,3,4}
matrix = [
  {-25.0,-43.0,-18.0,-29.0,-31.0},
  {-26.0,-39.0,-21.0,-27.0,-32.0},
  {-26.0,-39.0,-24.0,-25.0,-31.0}
  ]
point = {-26.0,-35.0,-21.0,-26.0,-27.0}
</code></pre>
<p>When graphed into a table, it would look like the following:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>labels[i]</th><th>matrix[i]</th><th>point</th></tr></thead><tbody>
<tr><td>0</td><td>2</td><td>-25.0,-43.0,-18.0,-29.0,-31.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
<tr><td>1</td><td>3</td><td>-26.0,-39.0,-21.0,-27.0,-32.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
<tr><td>2</td><td>4</td><td>-26.0,-39.0,-24.0,-25.0,-31.0</td><td>-26.0,-35.0,-21.0,-26.0,-27.0</td></tr>
</tbody></table>
</div>
<p>When the distances are calculated and paired, we get the following result:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>Pair(calculateDistance,labels[i])</th></tr></thead><tbody>
<tr><td>0</td><td>(98.0, 2)</td></tr>
<tr><td>1</td><td>(41.0, 3)</td></tr>
<tr><td>2</td><td>(41.0, 4)</td></tr>
</tbody></table>
</div>
<p>After calculating the <code>distances</code>, it is sorted according to the calculated distance which is the <code>first</code> item in the pair.</p>
<pre><code class="language-kt">distances.sortWith(compareBy {it.first})
</code></pre>
<p>Once sorted, the <code>distances</code> is now the following:</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>Pair(calculateDistance,labels[i])</th></tr></thead><tbody>
<tr><td>0</td><td>(41.0, 3)</td></tr>
<tr><td>1</td><td>(41.0, 4)</td></tr>
<tr><td>2</td><td>(98.0, 2)</td></tr>
</tbody></table>
</div>
<p>After sorting the <code>distances</code>, a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-map/"><code>hashmap</code></a>
is created in order to store the amount of neighbors for each classification (the number of cars or label).</p>
<p>For example:</p>
<blockquote>
<p><strong>NOTE:</strong> Additional data has been added in order to provide a more clear example.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>distances</th><th>label</th></tr></thead><tbody>
<tr><td>0</td><td>35.0</td><td>3</td></tr>
<tr><td>1</td><td>41.0</td><td>3</td></tr>
<tr><td>2</td><td>41.0</td><td>4</td></tr>
<tr><td>3</td><td>98.0</td><td>2</td></tr>
</tbody></table>
</div>
<p>When the data is stored into the hashmap, it can be seen like so:</p>
<pre><code class="language-kt">val hashmap = hashMapOf&lt;Int, Int&gt;()
// hashmap = {}

var end = k.coerceAtMost(matrix.size)
// matrix.size = 4
// since k = sqrt(matrix.size.toDouble()).toInt()
// k = 2 for this example
// therefore, end = 2

for (i in 0 until end){
  val classification = distances[i].second
  // In the pair, distance[0] = (35.0, 3)
  // By getting the second value in the pair
  // classification = 3

  hashmap[classification] = hashmap.getOrDefault(classification, 0)+1
  // hashmaps are similar to pairs, but they function differently.
  // hashmaps are key, value pairs
  // wherein the first element is the key and the second element is the value.
  // keys can be used as an index and they can store a value isolated from the items in the hashmap

  // in the line above, hashmap[classification] sets a value that gets paired to the classification
  // which in the case of the current i (0) is 3
  // So when it is visualized
  // hashmap = {3=null}
  // when hashmap.getOrDefault(classification, 0)+1 gets called
  // the value paired(null) to the classification(3) either gets set to
  // a number or set to the default value of 0 then incremented by 1
  // since the current value is null, it is set to 0 then incremented by 1
  // so after the first iteration hashmap = {3=1}

  // since this is in a loop until the end(2) is reached
  // the next iteration has the current values:
  // distance[1] = (41.0, 3)
  // classification = 3
  
  // now when hashmap.getOrDefault is ran,
  // hashmap[3] is already equal to 1 due to the previous iteration
  // so in this iteration, the value of hashmap[3] is incremented
  // hashmap = {3=2}
}
</code></pre>
<p>Due to the limitation set on the <code>k</code> value, the algorithm only had a single classification,
but if we are to go through all of the labels in <code>distances</code>, the hashmap would have the following value</p>
<pre><code class="language-kt">hashmap = {2=1, 3=2, 4=1}
</code></pre>
<p>These means that for the current point,
it has one neighbor classified as 2,
two neighbors classified as 3,
and one neighbor classified as 4.</p>
<p>After classifying the neighbors, the most number of neighbors of the same classification must be returned,
which is retrieved by the following lines of code:</p>
<pre><code class="language-kt">// set to -1 as the values of the hashmap
// would always be greater than this
var max = -1
// created to contain the classification
// of the greatest amount of neighbors
val outputs = arrayListOf&lt;Int&gt;()
for ((key, value) in hashmap) {
  if (value &gt; max) {
    max = value
    outputs.clear()
    outputs.add(key)
  } else if (value == max) {
    outputs.add(key)
  }
}
// The key is the one that gets added to the outputs
// as it is the classification which in the context of the application
// is the amount of cars taken

if (outputs.size == 1) {
  return outputs[0]
  // Given the examples above,
  // the output that gets returned is 3
  // which means that for that set of RSSI values
  // there are 3 parking spaces occupied
}
</code></pre>
<p>However, it could be possible for the neighbors to have different classifications,
yet the same amount of points.</p>
<p>For example:
hashmap = {2=1, 3=2, 4=1}</p>
<p>Which is why a tie-breaker is implemented like so:</p>
<pre><code class="language-kt">while (end &gt; 0) {
  end--
  val classification = distances[end].second
  // Decreases the value stored in that classification
  hashmap[classification]?.dec()
  // hashmap = {2=0, 3=1, 4=0}
  // this means that 3 is still the classification that gets returned
  // as it is only classification with the highest value

  max = -1
  outputs.clear()
  for ((key, value) in hashmap) {
    if (value &gt; max) {
      max = value
      outputs.clear()
      outputs.add(key)
    } else if (value == max) {
      outputs.add(key)
    }
  }

  if (outputs.size == 1) {
    return outputs[0]
  }
}
</code></pre>
<p>And if, for some reason all of the neighbors are all the same value like so:
hashmap = {2=1, 3=2, 4=1}</p>
<p>Then the algorithm would return the classification of the nearest neighbor:</p>
<pre><code class="language-kt">return distances[0].second
// distances[0] = (35.0, 3)
// which means that the classification still returned is 3
</code></pre>
<h3 id="loadmatrix"><a class="header" href="#loadmatrix">loadMatrix</a></h3>
<p>The <code>loadMatrix</code> method loads the matrix from an existing database.</p>
<h4 id="snippet-3"><a class="header" href="#snippet-3">Snippet</a></h4>
<pre><code class="language-kt">fun loadMatrix(data: ArrayList&lt;RowData&gt;) {
    inputSize = data.size

    labels.clear()
    matrix.clear()
    for (row in data) {
      labels.add(row.label)
      matrix.add(row.values)
    }

    k = sqrt(matrix.size.toDouble()).toInt()
  }
</code></pre>
<h4 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><code>data: ArrayList&lt;RowData&gt;</code></td><td>A list of <a href="chapters/row-data.html">RowData</a> which the matrix gets loaded from.</td></tr>
</tbody></table>
</div>
<h4 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h4>
<p>The start of the method overwrites the <code>inputSize</code> with the size of the <code>data</code> and clears the existing values of <code>labels</code> and <code>matrix</code>.</p>
<pre><code class="language-kt">inputSize = data.size

labels.clear()
matrix.clear()
</code></pre>
<p>After clearing the existing values in the database, the values from <code>data</code> gets added into the <code>labels</code> and <code>matrix</code> lists.</p>
<pre><code class="language-kt">// The same as:
// for (i in 0 until data.size){
//     var row = data[i]
//     labels.add(row.label)
//     matrix.add(row.values)
// }
for (row in data){
    labels.add(row.label)
    matrix.add(row.values)
}
</code></pre>
<p>Once the <code>labels</code> and <code>matrix</code> has been loaded from the <code>data</code>, the <code>k</code> value gets updated as well.</p>
<pre><code class="language-kt">k = sqrt(matrix.size.toDouble()).toInt()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router"><a class="header" href="#router">Router</a></h1>
<p>The <code>Router</code> class contains the information for each router the app connects to.
It is located at <code>app &gt; java &gt; com.silentrald.parkingrssi &gt; Router.kt</code>.</p>
<h2 id="fields-1"><a class="header" href="#fields-1">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>bssid</td><td><code>private var bssid: Long = 0L</code></td><td></td></tr>
<tr><td>bssidStr</td><td><code>private var bssidStr: String</code></td><td></td></tr>
<tr><td>name</td><td><code>private var name: String</code></td><td></td></tr>
<tr><td>row</td><td><code>var row: Int = 0</code></td><td></td></tr>
<tr><td>col</td><td><code>var col: Int = 0</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<h3 id="routerlong-string"><a class="header" href="#routerlong-string">Router(Long, String)</a></h3>
<p>Creates a router using a <code>Long</code> and <code>String</code> parameters.</p>
<h4 id="snippet-4"><a class="header" href="#snippet-4">Snippet</a></h4>
<pre><code class="language-kt">constructor(bssid: Long, name: String) {
    this.bssid = bssid
    this.name = name

    this.bssidStr = convertBSSIDToString(bssid)
}
</code></pre>
<h3 id="routerstring-string"><a class="header" href="#routerstring-string">Router(String, String)</a></h3>
<p>Creates a router using a <code>String</code> and <code>String</code> parameters.</p>
<h4 id="snippet-5"><a class="header" href="#snippet-5">Snippet</a></h4>
<pre><code class="language-kt">constructor(bssidStr: String, name: String) {
    this.bssidStr = bssidStr
    this.name = name

    this.bssid = convertBSSIDToLong(bssidStr)
}
</code></pre>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<h3 id="getbssid"><a class="header" href="#getbssid">getBSSID</a></h3>
<p>Returns the <code>bssid</code> of the router.</p>
<h4 id="snippet-6"><a class="header" href="#snippet-6">Snippet</a></h4>
<pre><code class="language-kt">fun getBSSID(): Long{
    return this.bssid
}
</code></pre>
<h3 id="getbssidstr"><a class="header" href="#getbssidstr">getBSSIDStr</a></h3>
<p>Returns the <code>bssidStr</code> of the router.</p>
<h4 id="snippet-7"><a class="header" href="#snippet-7">Snippet</a></h4>
<pre><code class="language-kt">fun getBSSIDStr(): String{
    return this.bssidStr
}
</code></pre>
<h3 id="getname"><a class="header" href="#getname">getName</a></h3>
<p>Returns the <code>name</code> of the router.</p>
<h4 id="snippet-8"><a class="header" href="#snippet-8">Snippet</a></h4>
<pre><code class="language-kt">fun getName(): String{
    return this.name
}
</code></pre>
<h3 id="convertbssidtolong"><a class="header" href="#convertbssidtolong">convertBSSIDToLong</a></h3>
<p>Formats the <code>bssidStr</code> to a <code>Long</code> type.</p>
<h4 id="snippet-9"><a class="header" href="#snippet-9">Snippet</a></h4>
<pre><code class="language-kt">private fun convertBSSIDToLong(bssidStr: String): Long {
    val str = bssidStr.replace(&quot;:&quot;, &quot;&quot;)

    return str.toLong(16)
}
</code></pre>
<h3 id="convertbssidtostring"><a class="header" href="#convertbssidtostring">convertBSSIDToString</a></h3>
<p>Formats the <code>bssid</code> to a <code>String</code> type.</p>
<h4 id="snippet-10"><a class="header" href="#snippet-10">Snippet</a></h4>
<pre><code class="language-kt">private fun convertBSSIDToString(bssid: Long): String {
    var bssidStr = bssid.toString(16)

    bssidStr = &quot;${
      bssidStr.substring(0, 2)
    }:${
      bssidStr.substring(2, 4)
    }:${
      bssidStr.substring(4, 6)
    }:${
      bssidStr.substring(6, 8)
    }:${
      bssidStr.substring(8, 10)
    }:${
      bssidStr.substring(10)
    }&quot;

    return bssidStr
}
</code></pre>
<h2 id="overrides"><a class="header" href="#overrides">Overrides</a></h2>
<h3 id="tostring"><a class="header" href="#tostring">toString</a></h3>
<p>Overrides the default toString method to the string set.</p>
<h4 id="snippet-11"><a class="header" href="#snippet-11">Snippet</a></h4>
<pre><code class="language-kt">override fun toString(): String{
    return &quot;$bssid: $name&lt;$bssidStr&gt; ($row, $col)&quot;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
